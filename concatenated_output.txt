"// # FILE: .\1config.yaml";
# Configuration file for HEXA FEM Topology Optimization, controlling geometry, material, optimization goals, and solver hyperparameters. 
 
# Domain dimension in the X direction (meters). 
# Domain dimension in the Y direction (meters). 
# Domain dimension in the Z direction (meters). 
# Target total number of elements. The mesh generator calculates N_x, N_y, N_z based on dimension ratios. 
# Shapes define fixed regions (void or solid) that are excluded from optimization. 
geometry: 
  length_x: 60 # Domain dimension in the X direction (meters). 
  length_y: 20 # Domain dimension in the Y direction (meters). 
  length_z: 20 # Domain dimension in the Z direction (meters). 
  target_elem_count: 1200000 # Target total number of elements. The mesh generator calculates N_x, N_y, N_z based on dimension ratios. 
  shape_notes: Shapes define fixed regions (void or solid) that are excluded from optimization. 
  sphere1: 
    # Geometric type: 'sphere' or 'box'. 
    type: sphere 
    # [X, Y, Z] coordinate of the shape center. 
    center: 
      - 12.510000228881836 
      - 5 
      - -13.991933822631836 
    # Diameter of the sphere. 
    diameter: 8 
    # Fixed density type: 'remove' (min_density) or 'add' (max_density_initial_add). 
    action: remove 
  sphere2: 
    # Geometric type: 'sphere' or 'box'. 
    type: sphere 
    # [X, Y, Z] coordinate of the shape center. 
    center: 
      - 9 
      - 5 
      - -6.200438976287842 
    # Diameter of the sphere. 
    diameter: 4 
    # Fixed density type: 'remove' (min_density) or 'add' (max_density_initial_add). 
    action: add 
  sphere3: 
    # Geometric type: 'sphere' or 'box'. 
    type: sphere 
    # [X, Y, Z] coordinate of the shape center. 
    center: 
      - 34.29201126098633 
      - 5 
      - -7.112380504608154 
    # Diameter of the sphere. 
    diameter: 4 
    # Fixed density type: 'remove' (min_density) or 'add' (max_density_initial_add). 
    action: remove 
  box2: 
    # Geometric type: 'sphere' or 'box'. 
    type: box 
    # [X, Y, Z] coordinate of the shape center. 
    center: 
      - 45.06150817871094 
      - 8.946874618530273 
      - -10.001893997192383 
    # Side length of the cube/box. 
    side: 4 
    # Fixed density type: 'remove' (min_density) or 'add' (max_density_initial_add). 
    action: remove 
  box1: 
    # Geometric type: 'sphere' or 'box'. 
    type: box 
    # [X, Y, Z] coordinate of the shape center. 
    center: 
      - 28 
      - 7 
      - -9.824102401733398 
    # Side length of the cube/box. 
    side: 2 
    # Fixed density type: 'remove' (min_density) or 'add' (max_density_initial_add). 
    action: add 
 
# Defines fixed displacement constraints on nodes matching the location criteria. 
boundary_conditions: 
  - location: 
      - 0 
      - ':' 
      - ':' 
    # Constrained Degrees of Freedom: 1=X translation, 2=Y translation, 3=Z translation. 
    DoFs: 
      - 1 
      - 2 
      - 3 
 
# Defines concentrated forces applied to nodes matching the location criteria. 
external_forces: 
  - location: 
      - 1 
      - 0 
      - 0.5 
    # Force vector [Fx, Fy, Fz] (applied as total force, distributed if using 'location'). 
    F: 
      - 0 
      - 10 
      - 0 
 
# Base material properties for solid elements. 
material:  
  E: 1 # Young's Modulus (base value). 
  nu: 0.3 # Poisson's Ratio. 
number_of_iterations: 30 
l1_stress_allowable: 1 
 
# Parameters related to the SIMP and density update rule. 
optimization_parameters: 
  min_density: 0.0001 # Minimum allowable element density (rho_min). Higher values increase stability but introduce 'gray' elements. Recommended: 0.001 to 0.01. 
  max_density_initial_add: 10 # Initial density for 'add' shapes (controls initial fixed stiffness). Typically >= 1.0. 
  density_clamp_max: 1 # Maximum value for element density. Usually 1.0. 
  filter_R_init_perc: 2.0 # Initial filter radius as a percentage of the largest domain dimension (e.g., 8.0 = 8%). 
  filter_R_interm_perc: 1.0 # Intermediate filter radius as a percentage of the largest domain dimension (e.g., 4.0 = 4%). 
  filter_R_final_perc: .25 # Final filter radius as a percentage of the largest domain dimension (e.g., 2.0 = 2%). 
  filter_R_interm_iter_perc: 80.0 # Iteration percentage at which intermediate radius is reached (e.g., 50.0 = half of total iterations). 
  filter_radius: 0.0 # The Filter Radius (R) - Now ignored if filter_R_init_perc > 0. 
 
# Parameters for selecting the solver type, tolerance, and numerical stability tuning. 
solver_parameters: 
  solver_type: gpu # Solver type: 'direct' (small problems), 'matrix_free' (CPU iterative), or 'gpu' (GPU iterative). 
  tolerance: 1e-7 # CG/Krylov solver convergence tolerance (Relative Residual Norm). Recommended 1e-6 or lower. 
  max_iterations: 30000 # Maximum number of iterations allowed for the chosen iterative solver (CG/Krylov). 
  diagonal_shift_factor: 1e-7 # Regularization factor (delta) applied as a fraction of max diagonal element. Critical for ill-conditioned matrices. Recommended 1e-6 to 1e-4. 
  gpu_method: krylov # If solver_type is 'gpu': 'native' (CUDA CG) or 'krylov' (Krylov.jl wrapper). 
  krylov_solver: cg # If gpu_method is 'krylov': Specify algorithm: 'cg', 'minres', or 'bicgstab'. 
"// # FILE: .\Boundary.jl";
module Boundary 
 
using JSON 
using SparseArrays 
 
 
export get_bc_indicator, reduce_system, apply_external_forces! 
 
""" 
    get_affected_nodes(spec, nodes) 
 
Returns an array of *final* node indices affected by this BC specification `spec`. 
`spec` can have: 
  - "node" => a direct 1-based node index (or array of indices) 
  - "location" => a 3-element array describing x, y, z selection in either absolute coords, 
                  fractions [0..1], or the wildcard ":". 
 
For example: 
  - "location": [0.0, ":", 1.0] 
    means "all nodes whose x-coordinate is near 0.0, any y, and z near maximum" 
""" 
function get_affected_nodes(spec::AbstractDict, nodes::Matrix{Float32}) 
     
    nNodes = size(nodes, 1) 
 
    # 1) If user gave "node" 
    if haskey(spec, "node") 
        raw = spec["node"] 
        if isa(raw, Integer) 
            idx = clamp(raw, 1, nNodes) 
            return [idx] 
        elseif isa(raw, AbstractVector) 
            node_list = Int[] 
            for r in raw 
                push!(node_list, clamp(r, 1, nNodes)) 
            end 
            return unique(node_list) 
        else 
            error("'node' must be an integer or an array of integers") 
        end 
    end 
 
    # 2) If user gave "location" 
    if haskey(spec, "location") 
        loc_array = spec["location"] 
        if length(loc_array) < 3 
            error("Location specification must have at least 3 components (x,y,z)") 
        end 
        return get_nodes_by_location(loc_array, nodes) 
    end 
 
    error("Specification must include either 'node' or 'location'") 
end 
 
""" 
    get_nodes_by_location(loc_array, nodes) 
 
Find nodes whose (x,y,z) coordinates match the "location" pattern. 
Each component in loc_array can be: 
  - a Number in [0..1], treated as a fraction of (min..max) 
  - a Number outside [0..1], treated as an absolute coordinate (with tolerance) 
  - a String like ":", meaning "all values" 
  - a String like "50%", meaning fraction 0.50 
""" 
function get_nodes_by_location(loc_array::AbstractVector, nodes::Matrix{Float32}) 
    xvals = @view nodes[:, 1] 
    yvals = @view nodes[:, 2] 
    zvals = @view nodes[:, 3] 
 
    xmin, xmax = extrema(xvals) 
    ymin, ymax = extrema(yvals) 
    zmin, zmax = extrema(zvals) 
 
    xspec = loc_array[1] 
    yspec = loc_array[2] 
    zspec = loc_array[3] 
 
    xmask = interpret_location_component(xspec, xvals, xmin, xmax) 
    ymask = interpret_location_component(yspec, yvals, ymin, ymax) 
    zmask = interpret_location_component(zspec, zvals, zmin, zmax) 
 
     
    return findall(xmask .& ymask .& zmask) 
end 
 
""" 
    interpret_location_component(spec, coords, cmin, cmax) 
 
Returns a Bool array indicating which nodes match 'spec' in this dimension. 
No references to literals with f0 suffix; we use Float32 casting explicitly. 
""" 
function interpret_location_component(spec, 
                                      coords::AbstractVector{Float32}, 
                                      cmin::Float32, cmax::Float32) 
    nNodes = length(coords) 
    mask = falses(nNodes) 
     
     
    tol = Float32(1e-6) * max(Float32(1.0), abs(cmax - cmin)) 
 
    if spec == ":" 
        return trues(nNodes) 
         
    elseif isa(spec, Number) 
        val = Float32(0.0) 
         
        if spec >= Float32(0.0) && spec <= Float32(1.0) 
            val = Float32(cmin + spec*(cmax - cmin)) 
        else 
            val = Float32(spec) 
        end 
         
        @inbounds for i in 1:nNodes 
            if abs(coords[i] - val) <= tol 
                mask[i] = true 
            end 
        end 
 
    elseif isa(spec, String) && endswith(spec, "%") 
        # e.g. "50%" => fraction 0.5 
        frac = parse(Float32, replace(spec, "%"=>"")) / Float32(100.0) 
        frac = clamp(frac, Float32(0.0), Float32(1.0)) 
        val = Float32(cmin + frac*(cmax - cmin)) 
         
        @inbounds for i in 1:nNodes 
            if abs(coords[i] - val) <= tol 
                mask[i] = true 
            end 
        end 
         
    else 
        error("Invalid location component: $spec") 
    end 
 
    return mask 
end 
 
""" 
    get_bc_indicator(nNodes, nodes, bc_data; T=Float32) 
 
Generates an (nNodes x 3) matrix with 1.0 where a boundary condition is applied, 
and 0.0 otherwise. We look up nodes by coordinate, not dims. 
""" 
function get_bc_indicator(nNodes::Int, 
                          nodes::Matrix{Float32}, 
                          bc_data::Vector{Any};  
                          T::Type{<:AbstractFloat} = Float32) 
 
    bc_indicator = zeros(T, nNodes, 3) 
     
    for bc in bc_data 
        dofs = bc["DoFs"] 
         
        for dof in dofs 
            if dof < 1 || dof > 3 
                error("Invalid DoF index: $dof (must be 1..3).") 
            end 
        end 
 
         
        affected = get_affected_nodes(bc, nodes) 
        for nd in affected 
            for d in dofs 
                bc_indicator[nd, d] = one(T) 
            end 
        end 
    end 
 
    return bc_indicator 
end 
 
""" 
    reduce_system(K, F, bc_data, nodes, elements) 
 
Use bc_data + final node array to mark constrained DOFs, 
then zero them out of the stiffness/force system. 
""" 
function reduce_system(K::SparseMatrixCSC{Float32,Int}, 
                       F::Vector{Float32}, 
                       bc_data::Vector{Any},  
                       nodes::Matrix{Float32}, 
                       elements::Matrix{Int}) 
 
    nNodes = size(nodes, 1) 
    ndof   = 3*nNodes 
    constrained = falses(ndof) 
 
    for bc in bc_data 
        dofs = bc["DoFs"] 
        affected = get_affected_nodes(bc, nodes) 
         
        for nd in affected 
            for d in dofs 
                gdof = 3*(nd-1) + d 
                constrained[gdof] = true 
                F[gdof] = Float32(0.0)  
            end 
        end 
    end 
 
    free_indices = findall(!, constrained) 
    K_reduced = K[free_indices, free_indices] 
    F_reduced = F[free_indices] 
     
    return K_reduced, F_reduced, free_indices 
end 
 
""" 
    apply_external_forces!(F, forces_data, nodes, elements) 
 
Look up affected nodes by coordinate or direct node index, 
then apply the force. 
If "location" is given, spread total force 
among all affected nodes equally. 
""" 
function apply_external_forces!(F::Vector{T}, 
                                 forces_data::Vector{Any},  
                                 nodes::Matrix{Float32}, 
                                 elements::Matrix{Int}) where T<:AbstractFloat 
 
    for force in forces_data 
        affected_nodes = get_affected_nodes(force, nodes) 
 
         
        if isempty(affected_nodes) 
            @warn "No nodes found for force specification; skipping this force: $(force)" 
            continue 
        end 
         
 
         
        f_raw = force["F"] 
        f_arr = zeros(T, 3) 
        len_to_copy = min(length(f_raw), 3) 
        f_arr[1:len_to_copy] = T.(f_raw[1:len_to_copy])  
 
        # If user gave "location", we spread the total force among the matched nodes 
         
        scale_factor = haskey(force, "location") ? (one(T) / length(affected_nodes)) : one(T) 
 
        for nd in affected_nodes 
            for i in 1:3 
                global_dof = 3*(nd-1) + i 
                F[global_dof] += scale_factor * f_arr[i] 
            end 
        end 
    end 
 
    return F 
end 
 
end 
"// # FILE: .\Configuration.jl";
module Configuration 
 
using YAML  
using ..Mesh  
using ..Helpers 
 
export load_configuration, setup_geometry, initialize_density_field 
 
""" 
    load_configuration(filename::String) 
 
Load and parse a JSON/YAML configuration file. 
""" 
function load_configuration(filename::String) 
    if !isfile(filename) 
        error("Configuration file '$(filename)' not found") 
    end 
     
    return YAML.load_file(filename) 
     
end 
 
""" 
    setup_geometry(config) 
 
Process the geometry configuration and return parameters for mesh generation. 
""" 
function setup_geometry(config) 
     
    length_x = config["geometry"]["length_x"] 
    length_y = config["geometry"]["length_y"] 
    length_z = config["geometry"]["length_z"] 
    target_elem_count = config["geometry"]["target_elem_count"] 
     
    println("Domain dimensions:") 
    println("  X: 0 to $(length_x)") 
    println("  Y: 0 to $(length_y)") 
    println("  Z: 0 to $(length_z)") 
     
     
    shapes_add = Any[] 
    shapes_remove = Any[] 
    for (key, shape) in config["geometry"] 
        # --- MODIFICATION START: Add "shape_notes" to the list of keys to ignore --- 
        if key in ["length_x", "length_y", "length_z", "target_elem_count", "shape_notes"] 
            continue 
        end 
         
        if haskey(shape, "type") 
            action = lowercase(get(shape, "action", "remove")) 
            if action == "add" 
                push!(shapes_add, shape) 
            elseif action == "remove" 
                push!(shapes_remove, shape) 
            else 
                @warn "Unknown action for shape '$key'. Defaulting to 'remove'." 
                push!(shapes_remove, shape) 
            end 
        else 
            @warn "Geometry key '$key' does not have a 'type' field; skipping." 
        end 
    end 
 
    println("Found $(length(shapes_add)) shapes to add and $(length(shapes_remove)) shapes to remove.") 
     
     
    nElem_x, nElem_y, nElem_z, dx, dy, dz, actual_elem_count = 
        Helpers.calculate_element_distribution(length_x, length_y, length_z, target_elem_count) 
     
    println("Mesh parameters:") 
    println("  Domain: $(length_x) x $(length_y) x $(length_z) meters") 
    println("  Elements: $(nElem_x) x $(nElem_y) x $(nElem_z) = $(actual_elem_count)") 
    println("  Element sizes: $(dx) x $(dy) x $(dz)") 
     
     
    max_domain_dim = max(length_x, length_y, length_z) 
 
    return ( 
        nElem_x = nElem_x,  
        nElem_y = nElem_y,  
        nElem_z = nElem_z, 
        dx = dx, 
        dy = dy, 
        dz = dz, 
        shapes_to_add = shapes_add, 
        shapes_to_remove = shapes_remove, 
        actual_elem_count = actual_elem_count, 
        max_domain_dim = Float32(max_domain_dim)  
    ) 
end 
 
""" 
    initialize_density_field(nodes, elements, shapes_to_add, shapes_to_remove, config) 
 
Processes geometric shapes to set the initial density array. 
Returns `density`, `original_density`, and `protected_elements_mask`. 
""" 
function initialize_density_field(nodes::Matrix{Float32}, 
                                  elements::Matrix{Int}, 
                                  shapes_to_add::Vector{Any}, 
                                  shapes_to_remove::Vector{Any}, 
                                  config::Dict) 
     
    min_density = Float32(get(config["optimization_parameters"], "min_density", 1e-3)) 
    max_density_add = Float32(get(config["optimization_parameters"], "max_density_initial_add", 10.0)) 
 
    nElem = size(elements, 1) 
    println("Processing geometric density modifications...") 
    density = ones(Float32, nElem) 
     
    # Process "add" shapes first (set density to max_density_add, typically 10.0) 
    for e in 1:nElem 
        centroid = Mesh.element_centroid(e, nodes, elements) 
        for shape in shapes_to_add 
            shape_type = lowercase(get(shape, "type", "")) 
             
            if shape_type == "sphere" 
                center = tuple(Float32.(shape["center"])...) 
                diam = Float32(shape["diameter"]) 
                if Mesh.inside_sphere(centroid, center, diam) 
                    density[e] = max_density_add # "Hard" 
                    break  
                end 
                 
            elseif shape_type == "box" 
                center = tuple(Float32.(shape["center"])...) 
                side = Float32(shape["side"]) 
                if Mesh.inside_box(centroid, center, side) 
                    density[e] = max_density_add # "Hard" 
                    break 
                end 
            end 
        end 
    end 
 
    # Process "remove" shapes second (set density to min_density) 
    for e in 1:nElem 
        centroid = Mesh.element_centroid(e, nodes, elements) 
        for shape in shapes_to_remove 
            shape_type = lowercase(get(shape, "type", "")) 
             
            if shape_type == "sphere" 
                center = tuple(Float32.(shape["center"])...) 
                diam = Float32(shape["diameter"]) 
                if Mesh.inside_sphere(centroid, center, diam) 
                    density[e] = min_density # "Soft" 
                    break 
                end 
                 
            elseif shape_type == "box" 
                center = tuple(Float32.(shape["center"])...) 
                side = Float32(shape["side"]) 
                if Mesh.inside_box(centroid, center, side) 
                    density[e] = min_density # "Soft" 
                    break 
                end 
            end 
        end 
    end 
     
    println("Element density processing complete. Min Density floor: $(min_density)") 
 
     
    original_density = copy(density) 
     
    protected_elements_mask = (original_density .!= 1.0f0) 
    num_protected = sum(protected_elements_mask) 
    println("Found $(num_protected) protected elements (voids/rigid) that will not be iterated.") 
 
    return density, original_density, protected_elements_mask 
end 
 
end 
"// # FILE: .\Element.jl";

module Element

using LinearAlgebra
export NAT_COORDS, shape_functions, material_matrix, hex_element_stiffness, get_canonical_stiffness, get_scalar_canonical_matrices

const NAT_COORDS = Float32[
    -1 -1 -1;
     1 -1 -1;
     1  1 -1;
    -1  1 -1;
    -1 -1  1;
     1 -1  1;
     1  1  1;
    -1  1  1
]

"""
    shape_functions(xi, eta, zeta)

Computes the trilinear shape functions and their derivatives at (xi, eta, zeta).
Returns (N, dN) with N=8 shape values, dN=8x3 derivative matrix.
"""
function shape_functions(xi, eta, zeta)
    N  = zeros(Float32, 8)
    dN = zeros(Float32, 8, 3)
    
    
    p1 = Float32(0.125)
    
    @inbounds for i in 1:8
        xi_i, eta_i, zeta_i = NAT_COORDS[i,1], NAT_COORDS[i,2], NAT_COORDS[i,3]
        
        term_xi   = (1.0f0 + xi*xi_i)
        term_eta  = (1.0f0 + eta*eta_i)
        term_zeta = (1.0f0 + zeta*zeta_i)
        
        N[i] = p1 * term_xi * term_eta * term_zeta
        
        dN[i,1] = p1 * xi_i * term_eta * term_zeta
        dN[i,2] = p1 * term_xi * eta_i * term_zeta
        dN[i,3] = p1 * term_xi * term_eta * zeta_i
    end
    return N, dN
end

"""
    material_matrix(E, nu)

Constructs the 6x6 isotropic material matrix for 3D elasticity.
"""
function material_matrix(E::Float32, nu::Float32)
    inv_den = 1.0f0 / ((1.0f0 + nu) * (1.0f0 - 2.0f0 * nu))
    factor = E * inv_den
    
    c1 = (1.0f0 - nu) * factor
    c2 = nu * factor
    c3 = ((1.0f0 - 2.0f0 * nu) / 2.0f0) * factor
    
    
    D = zeros(Float32, 6, 6)
    
    D[1,1] = c1; D[1,2] = c2; D[1,3] = c2
    D[2,1] = c2; D[2,2] = c1; D[2,3] = c2
    D[3,1] = c2; D[3,2] = c2; D[3,3] = c1
    
    D[4,4] = c3
    D[5,5] = c3
    D[6,6] = c3
    
    return D
end

"""
    hex_element_stiffness(nodes, E, nu)

Computes the 24x24 stiffness for a hex element.
"""
function hex_element_stiffness(nodes::AbstractMatrix{Float32}, E::Float32, nu::Float32)
    D = material_matrix(E, nu)
    ke = zeros(Float32, 24, 24)

    a = 1.0f0 / sqrt(3.0f0)
    gauss_pts = Float32[-a, a]
    
    
    B = zeros(Float32, 6, 24)

    @inbounds for xi in gauss_pts, eta in gauss_pts, zeta in gauss_pts
        
        _, dN_dxi = shape_functions(xi, eta, zeta)
        J    = transpose(dN_dxi) * nodes
        detJ = det(J)
        
        if detJ <= 0.0f0 
            
            
            
            error("Non-positive Jacobian detected in element stiffness calculation.")
        end
        
        invJ = inv(J)
        dN_dx = dN_dxi * transpose(invJ)

        fill!(B, 0.0f0)
        
        for i in 1:8
            idx = 3*(i-1)
            dN_i = view(dN_dx, i, :)

            B[1, idx+1] = dN_i[1]
            B[2, idx+2] = dN_i[2]
            B[3, idx+3] = dN_i[3]

            B[4, idx+1] = dN_i[2]
            B[4, idx+2] = dN_i[1]
            
            B[5, idx+2] = dN_i[3]
            B[5, idx+3] = dN_i[2]
            
            B[6, idx+1] = dN_i[3]
            B[6, idx+3] = dN_i[1]
        end

        
        ke .+= transpose(B) * D * B * detJ
    end

    return ke
end

"""
    get_canonical_stiffness(dx, dy, dz, nu)

Computes a "base" stiffness matrix for a standard rectangular element of size dx*dy*dz
with Young's Modulus E=1.0. 
This optimization significantly speeds up assembly for structured meshes.
"""
function get_canonical_stiffness(dx::Float32, dy::Float32, dz::Float32, nu::Float32)
    
    nodes = Float32[
        0.0 0.0 0.0;
        dx  0.0 0.0;
        dx  dy  0.0;
        0.0 dy  0.0;
        0.0 0.0 dz;
        dx  0.0 dz;
        dx  dy  dz;
        0.0 dy  dz
    ]
    
    nodes .-= [dx/2 dy/2 dz/2]
    
    return hex_element_stiffness(nodes, 1.0f0, nu)
end

"""
    get_scalar_canonical_matrices(dx, dy, dz)

Computes the 8x8 element Mass matrix (Me) and Stiffness/Laplacian matrix (Ke) 
for a scalar field (like density or temperature) on a rectangular Hex8 element.
Used for Helmholtz filtering.
"""
function get_scalar_canonical_matrices(dx::Float32, dy::Float32, dz::Float32)
    
    nodes = Float32[
        -dx/2 -dy/2 -dz/2;
         dx/2 -dy/2 -dz/2;
         dx/2  dy/2 -dz/2;
        -dx/2  dy/2 -dz/2;
        -dx/2 -dy/2  dz/2;
         dx/2 -dy/2  dz/2;
         dx/2  dy/2  dz/2;
        -dx/2  dy/2  dz/2
    ]

    Ke = zeros(Float32, 8, 8)
    Me = zeros(Float32, 8, 8)

    
    a = 1.0f0 / sqrt(3.0f0)
    gauss_pts = Float32[-a, a]

    @inbounds for xi in gauss_pts, eta in gauss_pts, zeta in gauss_pts
        N, dN_dxi = shape_functions(xi, eta, zeta)
        
        
        J = transpose(dN_dxi) * nodes
        detJ = det(J)
        invJ = inv(J)
        
        
        dN_dx = dN_dxi * transpose(invJ)
        
        weight = detJ 
        
        
        Ke .+= (dN_dx * transpose(dN_dx)) .* weight
        
        
        Me .+= (N * transpose(N)) .* weight
    end

    return Ke, Me
end

end
"// # FILE: .\ExportVTK.jl";

module ExportVTK 

using Printf 

export export_mesh, export_solution 

function export_mesh(nodes::Matrix{Float32}, 
                     elements::Matrix{Int}; 
                     bc_indicator=nothing, 
                     filename::String="mesh_output.vtu") 
     
    if !endswith(lowercase(filename), ".vtk") && !endswith(lowercase(filename), ".vtu") 
        filename *= ".vtk" 
    end 
     
    if any(isnan, nodes) || any(isinf, nodes) 
        @warn "Found NaN or Inf values in node coordinates. Replacing with zeros." 
        nodes = replace(nodes, NaN => Float32(0.0), Inf => Float32(0.0), -Inf => Float32(0.0)) 
    end 
     
    max_coord = maximum(abs.(nodes)) 
    if max_coord > Float32(1.0e10) 
        @warn "Very large coordinate values detected (maximum absolute value: $max_coord). Clamping to reasonable range." 
        nodes = clamp.(nodes, Float32(-1.0e10), Float32(1.0e10)) 
    end 

    nElem  = size(elements, 1) 
    nNodes = size(nodes, 1) 

    valid_elements = Int[] 
    for e = 1:nElem 
        elem_nodes = elements[e, :] 
        if any(n -> n < 1 || n > nNodes, elem_nodes) 
            @warn "Element $e has invalid node indices; skipping it entirely." 
        else 
            push!(valid_elements, e) 
        end 
    end 

    if isempty(valid_elements) 
        @warn "No valid elements found. Skipping VTK export." 
        return 
    end 

    nElem_valid = length(valid_elements) 
     
    try 
        open(filename, "w") do file 
            write(file, "# vtk DataFile Version 3.0\n") 
            write(file, "HEXA FEM Mesh (BINARY)\n") 
            write(file, "BINARY\n") 
            write(file, "DATASET UNSTRUCTURED_GRID\n") 
             
            write(file, "POINTS $(nNodes) float\n") 
            coords_flat = zeros(Float32, nNodes * 3) 
            for i in 1:nNodes 
                coords_flat[3*(i-1)+1] = nodes[i, 1] 
                coords_flat[3*(i-1)+2] = nodes[i, 2] 
                coords_flat[3*(i-1)+3] = nodes[i, 3] 
            end 
            write(file, hton.(coords_flat)) 
             
            write(file, "\nCELLS $(nElem_valid) $(nElem_valid * 9)\n") 
            cell_data = zeros(Int32, nElem_valid * 9) 
            for (idx_out, idx_in) in enumerate(valid_elements) 
                offset = (idx_out - 1) * 9 
                cell_data[offset + 1] = Int32(8) 
                for j in 1:8 
                    cell_data[offset + 1 + j] = Int32(elements[idx_in, j] - 1) 
                end 
            end 
            write(file, hton.(cell_data)) 
             
            write(file, "\nCELL_TYPES $(nElem_valid)\n") 
            cell_types = fill(Int32(12), nElem_valid) 
            write(file, hton.(cell_types)) 
             
            if bc_indicator !== nothing && size(bc_indicator, 1) == nNodes 
                write(file, "\nPOINT_DATA $(nNodes)\n") 
                ncols_bc = min(size(bc_indicator, 2), 3) 
                 
                if ncols_bc >= 2 
                    write(file, "VECTORS BC float\n") 
                    bc_data = zeros(Float32, nNodes * 3) 
                    for i in 1:nNodes 
                        if ncols_bc == 2 
                            bc_data[3*(i-1)+1] = bc_indicator[i, 1] 
                            bc_data[3*(i-1)+2] = bc_indicator[i, 2] 
                            bc_data[3*(i-1)+3] = Float32(0.0) 
                        else 
                            bc_data[3*(i-1)+1] = bc_indicator[i, 1] 
                            bc_data[3*(i-1)+2] = bc_indicator[i, 2] 
                            bc_data[3*(i-1)+3] = bc_indicator[i, 3] 
                        end 
                    end 
                    write(file, hton.(bc_data)) 
                else 
                    write(file, "SCALARS BCx float 1\n") 
                    write(file, "LOOKUP_TABLE default\n") 
                    bc_data = [bc_indicator[i, 1] for i in 1:nNodes] 
                    write(file, hton.(bc_data)) 
                end 
            end 
        end 
         
        println("Successfully exported mesh to $filename (BINARY format)") 
    catch e 
        @error "Failed to save VTK file: $e" 
        println("Error details: ", e) 
    end 
end 

function export_solution(nodes::Matrix{Float32}, 
                         elements::Matrix{Int}, 
                         U_full::Vector{Float32}, 
                         F::Vector{Float32}, 
                         bc_indicator::Matrix{Float32}, 
                         principal_field::Matrix{Float32}, 
                         vonmises_field::Vector{Float32}, 
                         full_stress_voigt::Matrix{Float32}, 
                         l1_stress_norm_field::Vector{Float32}; 
                         density::Union{Vector{Float32}, Nothing}=nothing,
                         scale::Float32=Float32(1.0), 
                         filename::String="solution_output.vtu") 

    function sanitize_data(data) 
        data = replace(data, NaN => Float32(0.0), Inf => Float32(0.0), -Inf => Float32(0.0)) 
        max_val = maximum(abs.(data)) 
        if max_val > Float32(1.0e10) 
            @warn "Very large values detected (max abs: $max_val). Clamping to prevent ParaView crashes." 
            return clamp.(data, Float32(-1.0e10), Float32(1.0e10)) 
        end 
        return data 
    end 
     
    U_full = sanitize_data(U_full) 
    F = sanitize_data(F) 
    nodes = sanitize_data(nodes) 
    principal_field = sanitize_data(principal_field) 
    vonmises_field = sanitize_data(vonmises_field) 
    full_stress_voigt = sanitize_data(full_stress_voigt) 
    l1_stress_norm_field = sanitize_data(l1_stress_norm_field) 

    nNodes = size(nodes, 1) 
    nElem  = size(elements, 1) 

    valid_elements = Int[] 
    for e = 1:nElem 
        elem_nodes = elements[e, :] 
        if any(n -> n < 1 || n > nNodes, elem_nodes) 
            @warn "Element $e has invalid node indices; skipping it." 
        else 
            push!(valid_elements, e) 
        end 
    end 

    nElem_valid = length(valid_elements) 
    if nElem_valid == 0 
        @warn "No valid elements remain. Skipping solution export." 
        return 
    end 

    function ensure_array_size(arr, expected_size, pad_value=Float32(0.0)) 
        if length(arr) < expected_size 
            return vcat(arr, fill(pad_value, expected_size - length(arr))) 
        elseif length(arr) > expected_size 
            return arr[1:expected_size] 
        else 
            return arr 
        end 
    end 
     
    U_full = ensure_array_size(U_full, 3*nNodes) 
    F = ensure_array_size(F, 3*nNodes) 
     
    displacement = zeros(Float32, nNodes, 3) 
    forces = zeros(Float32, nNodes, 3) 
     
    for i in 1:nNodes 
        base_idx = 3*(i-1) 
        if base_idx + 3 <= length(U_full) 
            displacement[i, 1] = U_full[base_idx + 1] 
            displacement[i, 2] = U_full[base_idx + 2] 
            displacement[i, 3] = U_full[base_idx + 3] 
        end 
         
        if base_idx + 3 <= length(F) 
            forces[i, 1] = F[base_idx + 1] 
            forces[i, 2] = F[base_idx + 2] 
            forces[i, 3] = F[base_idx + 3] 
        end 
    end 
     
    disp_mag = sqrt.(sum(displacement.^2, dims=2))[:,1]   

    max_disp = maximum(abs.(displacement)) 
    if max_disp > 0 
        max_dim = maximum([ 
            maximum(nodes[:,1]) - minimum(nodes[:,1]), 
            maximum(nodes[:,2]) - minimum(nodes[:,2]), 
            maximum(nodes[:,3]) - minimum(nodes[:,3]) 
        ]) 
        if scale * max_disp > max_dim * 5 
            @warn "Scale factor causes very large deformation => auto reducing." 
            scale = Float32(0.5) * max_dim / max_disp 
        end 
    end 

    deformed_nodes = copy(nodes) 
    @inbounds for i in 1:nNodes 
        deformed_nodes[i,1] += scale*displacement[i,1] 
        deformed_nodes[i,2] += scale*displacement[i,2] 
        deformed_nodes[i,3] += scale*displacement[i,3] 
    end 
     
    deformed_nodes = sanitize_data(deformed_nodes) 

    if size(principal_field, 2) < nElem 
        principal_field = hcat(principal_field, zeros(Float32, 3, nElem - size(principal_field, 2))) 
    end 
     
    vonmises_field = ensure_array_size(vonmises_field, nElem) 
    l1_stress_norm_field = ensure_array_size(l1_stress_norm_field, nElem) 
     
    if size(full_stress_voigt, 2) < nElem 
        full_stress_voigt = hcat(full_stress_voigt, zeros(Float32, 6, nElem - size(full_stress_voigt, 2))) 
    end 
     
    principal_field_valid = principal_field[:, valid_elements] 
    vonmises_field_valid = vonmises_field[valid_elements] 
    l1_stress_norm_field_valid = l1_stress_norm_field[valid_elements] 
    full_stress_voigt_valid = full_stress_voigt[:, valid_elements] 

    
    if endswith(lowercase(filename), ".vtk") || 
       endswith(lowercase(filename), ".vtu") 
        base_filename = filename[1:end-4] 
    else 
        base_filename = filename 
    end 
     
    
    combined_filename = base_filename * "_combined.vtk"

    try 
        open(combined_filename, "w") do file 
            write(file, "# vtk DataFile Version 3.0\n") 
            write(file, "HEXA FEM Solution (Combined Data - BINARY)\n") 
            write(file, "BINARY\n") 
            write(file, "DATASET UNSTRUCTURED_GRID\n") 
             
            
            write(file, "POINTS $(nNodes) float\n") 
            coords_flat = zeros(Float32, nNodes * 3) 
            for i in 1:nNodes 
                coords_flat[3*(i-1)+1] = nodes[i, 1] 
                coords_flat[3*(i-1)+2] = nodes[i, 2] 
                coords_flat[3*(i-1)+3] = nodes[i, 3] 
            end 
            write(file, hton.(coords_flat)) 
             
            write(file, "\nCELLS $(nElem_valid) $(nElem_valid * 9)\n") 
            cell_data = zeros(Int32, nElem_valid * 9) 
            for (idx_out, idx_in) in enumerate(valid_elements) 
                offset = (idx_out - 1) * 9 
                cell_data[offset + 1] = Int32(8) 
                for j in 1:8 
                    cell_data[offset + 1 + j] = Int32(elements[idx_in, j] - 1) 
                end 
            end 
            write(file, hton.(cell_data)) 
             
            write(file, "\nCELL_TYPES $(nElem_valid)\n") 
            cell_types = fill(Int32(12), nElem_valid) 
            write(file, hton.(cell_types)) 
             
            
            write(file, "\nPOINT_DATA $(nNodes)\n") 
             
            
            write(file, "VECTORS Displacement float\n") 
            disp_flat = zeros(Float32, nNodes * 3) 
            for i in 1:nNodes 
                disp_flat[3*(i-1)+1] = displacement[i, 1] 
                disp_flat[3*(i-1)+2] = displacement[i, 2] 
                disp_flat[3*(i-1)+3] = displacement[i, 3] 
            end 
            write(file, hton.(disp_flat)) 
             
            
            write(file, "\nSCALARS Displacement_Magnitude float 1\n") 
            write(file, "LOOKUP_TABLE default\n") 
            write(file, hton.(disp_mag)) 
             
            
            write(file, "\nVECTORS Force float\n") 
            force_flat = zeros(Float32, nNodes * 3) 
            for i in 1:nNodes 
                force_flat[3*(i-1)+1] = forces[i, 1] 
                force_flat[3*(i-1)+2] = forces[i, 2] 
                force_flat[3*(i-1)+3] = forces[i, 3] 
            end 
            write(file, hton.(force_flat)) 
             
            
            if size(bc_indicator, 1) == nNodes 
                ncols_bc = min(size(bc_indicator, 2), 3) 
                if ncols_bc >= 2 
                    write(file, "\nVECTORS BC float\n") 
                    bc_data = zeros(Float32, nNodes * 3) 
                    for i in 1:nNodes 
                        if ncols_bc == 2 
                            bc_data[3*(i-1)+1] = bc_indicator[i, 1] 
                            bc_data[3*(i-1)+2] = bc_indicator[i, 2] 
                            bc_data[3*(i-1)+3] = Float32(0.0) 
                        else 
                            bc_data[3*(i-1)+1] = bc_indicator[i, 1] 
                            bc_data[3*(i-1)+2] = bc_indicator[i, 2] 
                            bc_data[3*(i-1)+3] = bc_indicator[i, 3] 
                        end 
                    end 
                    write(file, hton.(bc_data)) 
                else 
                    write(file, "\nSCALARS BC float 1\n") 
                    write(file, "LOOKUP_TABLE default\n") 
                    bc_data = [bc_indicator[i, 1] for i in 1:nNodes] 
                    write(file, hton.(bc_data)) 
                end 
            end 
             
            
            write(file, "\nCELL_DATA $(nElem_valid)\n") 
             
            
            write(file, "SCALARS Von_Mises_Stress float 1\n") 
            write(file, "LOOKUP_TABLE default\n") 
            write(file, hton.(vonmises_field_valid)) 
             
            
            write(file, "\nSCALARS l1_stress_norm float 1\n") 
            write(file, "LOOKUP_TABLE default\n") 
            write(file, hton.(l1_stress_norm_field_valid)) 
             
            
            write(file, "\nVECTORS Principal_Stress float\n") 
            principal_flat = zeros(Float32, nElem_valid * 3) 
            for i in 1:nElem_valid 
                principal_flat[3*(i-1)+1] = principal_field_valid[1, i] 
                principal_flat[3*(i-1)+2] = principal_field_valid[2, i] 
                principal_flat[3*(i-1)+3] = principal_field_valid[3, i] 
            end 
            write(file, hton.(principal_flat)) 
             
            
            stress_names = ["Stress_XX", "Stress_YY", "Stress_ZZ", "Stress_XY", "Stress_YZ", "Stress_XZ"] 
            for idx in 1:6 
                write(file, "\nSCALARS $(stress_names[idx]) float 1\n") 
                write(file, "LOOKUP_TABLE default\n") 
                stress_component = [full_stress_voigt_valid[idx, i] for i in 1:nElem_valid] 
                write(file, hton.(stress_component)) 
            end 

            
            if density !== nothing
                write(file, "\nSCALARS Element_Density float 1\n")
                write(file, "LOOKUP_TABLE default\n")
                density_valid = density[valid_elements]
                write(file, hton.(density_valid))
            end
        end 
         
        println("Successfully exported combined solution to $combined_filename (BINARY format)") 
        println("File contains: displacement, forces, BCs, stress tensors, and element density")
        
    catch e 
        @error "Failed to save combined VTK file: $e" 
        println("Error details: ", e) 
    end 

    return nothing 
end 

end
"// # FILE: .\Helpers.jl";
module Helpers 
 
using CUDA 
 
export expand_element_indices, nodes_from_location, parse_location_component 
export calculate_element_distribution, has_enough_gpu_memory, clear_gpu_memory 
 
function expand_element_indices(elem_inds, dims) 
    nElem_x = dims[1] - 1 
    nElem_y = dims[2] - 1 
    nElem_z = dims[3] - 1 
    inds = Vector{Vector{Int}}() 
    for d in 1:3 
        if (typeof(elem_inds[d]) == String && elem_inds[d] == ":") 
            if d == 1 
                push!(inds, collect(1:nElem_x)) 
            elseif d == 2 
                push!(inds, collect(1:nElem_y)) 
            elseif d == 3 
                push!(inds, collect(1:nElem_z)) 
            end 
        else 
            push!(inds, [Int(elem_inds[d])]) 
        end 
    end 
    result = Int[] 
    for i in inds[1], j in inds[2], k in inds[3] 
        eidx = i + (j-1)*nElem_x + (k-1)*nElem_x*nElem_y 
        push!(result, eidx) 
    end 
    return result 
end 
 
""" 
    nodes_from_location(loc, dims) 
 
Determines node indices from a non‑dimensional location specification. 
loc: 3-element vector, each can be a number, ":" or "X%". 
dims: (nNodes_x, nNodes_y, nNodes_z). 
""" 
function nodes_from_location(loc::Vector, dims) 
    nNodes_x, nNodes_y, nNodes_z = dims 
    ix = parse_location_component(loc[1], nNodes_x) 
    iy = parse_location_component(loc[2], nNodes_y) 
    iz = parse_location_component(loc[3], nNodes_z) 
    nodes = Int[] 
    for k in iz, j in iy, i in ix 
        node = i + (j-1)*nNodes_x + (k-1)*nNodes_x*nNodes_y 
        push!(nodes, node) 
    end 
    return nodes 
end 
 
function parse_location_component(val, nNodes::Int) 
    if val == ":" 
        return collect(1:nNodes) 
    elseif isa(val, String) && endswith(val, "%") 
        perc = parse(Float64, replace(val, "%"=>"")) / 100.0 
        idx = round(Int, 1 + perc*(nNodes-1)) 
        return [idx] 
    elseif isa(val, Number) 
        if 0.0 <= val <= 1.0 
            idx = round(Int, 1 + val*(nNodes-1)) 
            return [idx] 
        else 
            idx = clamp(round(Int, val), 1, nNodes) 
            return [idx] 
        end 
    else 
        error("Invalid location component: $val") 
    end 
end 
 
 
 
 
function clear_gpu_memory() 
    if !CUDA.functional() 
        println("No GPU available.") 
        return (0, 0) 
    end 
    GC.gc() 
    CUDA.reclaim() 
 
    final_free, total = CUDA.available_memory(), CUDA.total_memory() 
    return (final_free, total) 
end 
 
function estimate_gpu_memory_required(nNodes, nElem) 
    ndof = nNodes * 3 
    nnz_estimate = ndof * 27 
     
    sparse_matrix_mem = nnz_estimate * (8 + 8) 
    vectors_mem = ndof * 8 * 10 
    element_matrices_mem = nElem * 24 * 24 * 8 
    buffer_mem = (sparse_matrix_mem + vectors_mem) * 0.5 
    total_mem = sparse_matrix_mem + vectors_mem + element_matrices_mem + buffer_mem 
    return total_mem 
end 
 
function has_enough_gpu_memory(nNodes, nElem) 
    if !CUDA.functional() 
        return false 
    end 
    try 
        free_mem, total_mem = CUDA.available_memory(), CUDA.total_memory() 
        required_mem = estimate_gpu_memory_required(nNodes, nElem) 
        usable_mem = free_mem * 0.95 
        println("Estimated GPU memory required: $(round(required_mem/1024^3, digits=2)) GB") 
        println("Available GPU memory: $(round(free_mem/1024^3, digits=2)) GB (Total: $(round(total_mem/1024^3, digits=2)) GB)") 
        println("Using $(round(required_mem/free_mem*100, digits=2))% of available GPU memory") 
        has_enough = required_mem < usable_mem 
        println("Has enough GPU memory: $(has_enough)") 
        return has_enough 
    catch e 
        println("Error checking GPU memory: $e") 
        return false 
    end 
end 
 
function calculate_element_distribution(length_x, length_y, length_z, target_elem_count) 
    total_volume = length_x * length_y * length_z 
     
    ratio_x = length_x / cbrt(total_volume) 
    ratio_y = length_y / cbrt(total_volume) 
    ratio_z = length_z / cbrt(total_volume) 
 
    base_count = cbrt(target_elem_count) 
    nElem_x = max(1, round(Int, base_count * ratio_x)) 
    nElem_y = max(1, round(Int, base_count * ratio_y)) 
    nElem_z = max(1, round(Int, base_count * ratio_z)) 
 
    dx = length_x / nElem_x 
    dy = length_y / nElem_y 
    dz = length_z / nElem_z 
    actual_elem_count = nElem_x * nElem_y * nElem_z 
    return nElem_x, nElem_y, nElem_z, Float32(dx), Float32(dy), Float32(dz), actual_elem_count 
end 
 
end 
"// # FILE: .\Main.jl";

module HEXA

using LinearAlgebra, SparseArrays, Printf, Base.Threads, JSON, Dates
using CUDA
using YAML

include("Helpers.jl")
include("Element.jl")
include("Mesh.jl")
include("Boundary.jl")
include("ExportVTK.jl")
include("Stress.jl")


include("SOLVER/CPUSolver.jl")
include("SOLVER/GPUSolver.jl")
include("SOLVER/IterativeSolver.jl")
include("SOLVER/DirectSolver.jl")
include("SOLVER/Solver.jl")


include("Configuration.jl")
include("TopologyOptimization.jl")
include("Postprocessing.jl")


using .Helpers
using .Element
using .Mesh
using .Boundary
using .ExportVTK
using .Stress
using .CPUSolver
using .GPUSolver
using .Solver
using .Configuration
using .TopologyOptimization
using .Postprocessing

function __init__()
    println("HEXA Finite Element Solver initialized")
    println("Active Threads = $(Threads.nthreads())")
    println("Clearing GPU memory...")
    Helpers.clear_gpu_memory()
end

"""
    run_main(config_file=nothing)

Run the main HEXA simulation using the configuration from the specified JSON/YAML file.
"""
function run_main(config_file=nothing)
    
    if config_file === nothing
        config_file = "config.yaml"
    end
    

    println("Loading configuration from: $config_file")
    config = load_configuration(config_file)
    
    geom = setup_geometry(config)
    
    
    
    
    
    config["geometry"]["nElem_x_computed"] = geom.nElem_x
    config["geometry"]["nElem_y_computed"] = geom.nElem_y
    config["geometry"]["nElem_z_computed"] = geom.nElem_z
    config["geometry"]["dx_computed"] = geom.dx
    config["geometry"]["dy_computed"] = geom.dy
    config["geometry"]["dz_computed"] = geom.dz
    
    config["geometry"]["max_domain_dim"] = geom.max_domain_dim
    

    
    println("\nGenerating structured prismatic mesh...")
    nodes, elements, dims = generate_mesh(
        geom.nElem_x, geom.nElem_y, geom.nElem_z;
        dx = geom.dx, dy = geom.dy, dz = geom.dz
    )
    
    nNodes = size(nodes, 1)
    nElem = size(elements, 1)
    println("Final mesh statistics:")
    println("  Nodes: $(nNodes)")
    println("  Elements: $(nElem)")
    
    bc_data = config["boundary_conditions"]
    
    bc_indicator = get_bc_indicator(nNodes, nodes, Vector{Any}(bc_data))
    
    
    E = Float32(config["material"]["E"])
    nu = Float32(config["material"]["nu"])
    println("Material properties: E=$(E), nu=$(nu)")
    
    ndof = nNodes * 3
    F = zeros(Float32, ndof)
    forces_data = config["external_forces"]
    
    apply_external_forces!(F, Vector{Any}(forces_data), nodes, elements)
    
    
    number_of_iterations = get(config, "number_of_iterations", 0)
    l1_stress_allowable = Float32(get(config, "l1_stress_allowable", 1.0))

    if l1_stress_allowable == 0.0f0
        @warn "l1_stress_allowable is 0. Setting to 1.0f0 to avoid division by zero."
        l1_stress_allowable = 1.0f0
    end
    
    
    density, original_density, protected_elements_mask = 
        initialize_density_field(nodes, elements, geom.shapes_to_add, geom.shapes_to_remove, config)
    

    
    opt_params = config["optimization_parameters"]
    min_density = Float32(get(opt_params, "min_density", 1.0e-3))
    max_density_clamp = Float32(get(opt_params, "density_clamp_max", 1.0))

    
    base_name = splitext(basename(config_file))[1]

    
    U_full = zeros(Float32, ndof)
    principal_field = zeros(Float32, 3, nElem)
    vonmises_field = zeros(Float32, nElem)
    full_stress_voigt = zeros(Float32, 6, nElem)
    l1_stress_norm_field = zeros(Float32, nElem)

    
    
    
    RESULTS_DIR = "RESULTS"
    mkpath(RESULTS_DIR)
    println("All outputs will be saved to: $RESULTS_DIR")

    if number_of_iterations == 0
        println("number_of_iterations = 0, performing a single analysis.")
    else
        println("Starting iterative analysis. Base iterations: $number_of_iterations")
    end

    iter = 1
    keep_running = true
    is_annealing = false
    max_annealing_iters = 100 
    convergence_threshold = 0.01 

    while keep_running
        
        
        if number_of_iterations > 0 && iter > number_of_iterations
            is_annealing = true
            annealing_idx = iter - number_of_iterations
            
            println("\n--- Starting Annealing Iteration $annealing_idx (Global: $iter) ---")
            
            
            if annealing_idx > max_annealing_iters
                println("⚠️ Max annealing iterations ($max_annealing_iters) reached. Stopping.")
                break
            end
        elseif number_of_iterations > 0
            println("\n--- Starting Iteration $(iter) / $(number_of_iterations) ---")
        end

        # Ensure "soft" and "hard" elements are reset
        if iter > 1
            println("Verifying protected element densities before FE analysis...")
            for e in 1:nElem
                if protected_elements_mask[e]
                    density[e] = original_density[e]
                end
            end
        end

        
        println("Calling unified solver...")
        U_full = Solver.solve_system(
            nodes, elements, E, nu, bc_indicator, F;
            density=density,
            config=config,
            
            min_stiffness_threshold=min_density
            
        )
        
        
        principal_field, vonmises_field, full_stress_voigt, l1_stress_norm_field =
            compute_stress_field(nodes, elements, U_full, E, nu, density)
        

        
        
        export_iteration_results(
            iter, base_name, RESULTS_DIR, nodes, elements,
            U_full, F, bc_indicator, principal_field,
            vonmises_field, full_stress_voigt,
            l1_stress_norm_field, density, E,
            geom 
        )
        

        
        
        
        if number_of_iterations > 0
            
            
            # Pass 'is_annealing' to control threshold (98%) and radius (>= 1 elem)
            max_change = update_density!(
                density, l1_stress_norm_field, protected_elements_mask,
                E, l1_stress_allowable, iter, number_of_iterations,
                original_density,
                min_density, max_density_clamp,
                config,
                is_annealing
            )
            
            
            if is_annealing
                if max_change < convergence_threshold
                    println("\n✅ CONVERGENCE REACHED: Topology change $(@sprintf("%.4f%%", max_change*100)) < 1.0%")
                    keep_running = false
                else
                    println("⏳ Annealing... Change: $(@sprintf("%.4f%%", max_change*100)) (Target: < 1.0%)")
                end
            elseif iter == number_of_iterations
                println("Base iterations complete. Entering annealing phase...")
            end
            
        else
            
            keep_running = false
        end

        
        if CUDA.functional()
            println("Clearing GPU memory between iterations...")
            Helpers.clear_gpu_memory()
        end
        
        iter += 1
    end

    println("Clearing GPU memory...")
    Helpers.clear_gpu_memory()
    
    return (
        nodes = nodes,
        elements = elements,
        displacements = U_full,
        principal_stress = principal_field,
        vonmises_stress = vonmises_field,
        l1_stress_norm = l1_stress_norm_field,
        stress_tensor = full_stress_voigt
    )
end

end

using .HEXA

config_path = joinpath(@__DIR__, "config.yaml")

user_prompt_config = raw"H:\WORK\PhD\HEXAS\2025_11_26_HEXAS_TOPO\HEXAS_FEM-main\config.yaml"


if isfile(user_prompt_config)
    HEXA.run_main(user_prompt_config)
elseif isfile(config_path)
    println("User-specified config not found, using default: $config_path")
    HEXA.run_main(config_path)
else
    @error "Neither user-specified config nor default config.yaml found."
end
"// # FILE: .\Mesh.jl";
module Mesh 
 
export node_index, generate_mesh, element_centroid, inside_sphere, inside_box 
 
using LinearAlgebra, Printf 
 
""" 
    node_index(i, j, k, nNodes_x, nNodes_y) 
 
Converts 3D indices (i, j, k) into a linear node index (column‑major ordering). 
""" 
function node_index(i, j, k, nNodes_x, nNodes_y) 
    return i + (j-1)*nNodes_x + (k-1)*nNodes_x*nNodes_y 
end 
 
""" 
    element_centroid(e, nodes, elements) 
 
Computes the centroid of element `e` given the node coordinates. 
""" 
function element_centroid(e, nodes, elements) 
    conn = elements[e, :] 
    elem_nodes = nodes[conn, :] 
    c = zeros(Float32, 3) 
    for i in 1:8 
        c .+= elem_nodes[i, :] 
    end 
    return c ./ Float32(8.0)  
end 
 
""" 
    inside_sphere(pt::Vector{Float32}, center::Tuple{Float32,Float32,Float32}, diam::Float32) 
 
Helper function to check if a point is inside a sphere. 
""" 
function inside_sphere(pt::Vector{Float32}, center::Tuple{Float32,Float32,Float32}, diam::Float32) 
    r = diam / Float32(2.0)  
    return norm(pt .- collect(center)) <= r 
end 
 
""" 
    inside_box(pt::Vector{Float32}, center::Tuple{Float32,Float32,Float32}, side::Float32) 
 
Helper function to check if a point is inside a box. 
""" 
function inside_box(pt::Vector{Float32}, center::Tuple{Float32,Float32,Float32}, side::Float32) 
    half = side / Float32(2.0)  
    return abs(pt[1] - center[1]) <= half && 
           abs(pt[2] - center[2]) <= half && 
           abs(pt[3] - center[3]) <= half 
end 
 
""" 
    generate_mesh(nElem_x, nElem_y, nElem_z; 
                  dx=1.0f0, dy=1.0f0, dz=1.0f0) 
 
Generates a structured (prismatic) hexahedral mesh. 
This function no longer modifies the mesh based on shapes. 
""" 
function generate_mesh(nElem_x::Int, nElem_y::Int, nElem_z::Int; 
                       dx::Float32=Float32(1.0),  
                       dy::Float32=Float32(1.0),  
                       dz::Float32=Float32(1.0))  
     
     
    nNodes_x = nElem_x + 1 
    nNodes_y = nElem_y + 1 
    nNodes_z = nElem_z + 1 
    dims = (nNodes_x, nNodes_y, nNodes_z) 
       
    nNodes = nNodes_x * nNodes_y * nNodes_z 
    nodes = zeros(Float32, nNodes, 3) 
    idx = 1 
    for k in 1:nNodes_z, j in 1:nNodes_y, i in 1:nNodes_x 
        nodes[idx, :] = [(i-1)*dx, (j-1)*dy, (k-1)*dz] 
        idx += 1 
    end 
     
    nElem = (nNodes_x - 1) * (nNodes_y - 1) * (nNodes_z - 1) 
    elements = Matrix{Int}(undef, nElem, 8) 
    elem_idx = 1 
    for k in 1:(nNodes_z-1), j in 1:(nNodes_y-1), i in 1:(nNodes_x-1) 
        n1 = node_index(i, j, k, nNodes_x, nNodes_y) 
        n2 = node_index(i+1, j, k, nNodes_x, nNodes_y) 
        n3 = node_index(i+1, j+1, k, nNodes_x, nNodes_y) 
        n4 = node_index(i, j+1, k, nNodes_x, nNodes_y) 
        n5 = node_index(i, j, k+1, nNodes_x, nNodes_y) 
        n6 = node_index(i+1, j, k+1, nNodes_x, nNodes_y) 
        n7 = node_index(i+1, j+1, k+1, nNodes_x, nNodes_y) 
        n8 = node_index(i, j+1, k+1, nNodes_x, nNodes_y) 
        elements[elem_idx, :] = [n1, n2, n3, n4, n5, n6, n7, n8] 
        elem_idx += 1 
    end 
 
    println("Generated structured mesh: $(nElem) elements, $(nNodes) nodes.") 
 
    return nodes, elements, dims 
end 
 
end 
"// # FILE: .\MeshShapeProcessing.jl";
module MeshShapeProcessing 
 
export process_add_shape!, process_remove_shape! 
 
using LinearAlgebra 
using ..Element       
using ..MeshUtilities   
 
""" 
    process_add_shape!(shape, nodes, dx, dy, dz) 
Generic “add” routine that returns new element connectivities  
(but does not modify your main `elements`).  
""" 
function process_add_shape!(shape::Dict, nodes, dx, dy, dz) 
    shape_type = lowercase(shape["type"]) 
    if shape_type == "sphere" 
        return make_sphere_elements(shape, nodes, dx, dy, dz) 
    elseif shape_type == "box" 
        return make_box_elements(shape, nodes, dx, dy, dz) 
    else 
        @warn "Unknown shape type for 'add': $shape_type" 
        return NTuple{8,Int}[] 
    end 
end 
 
""" 
    process_remove_shape!(shape, nodes, elements, remove_mask) 
Mark `remove_mask[e] = true` if the element's centroid is inside shape. 
""" 
function process_remove_shape!(shape::Dict, 
                              nodes::Matrix{Float32}, 
                              elements::Matrix{Int}, 
                              remove_mask::BitVector) 
    shape_type = lowercase(shape["type"]) 
    if shape_type == "sphere" 
        remove_sphere!(shape, nodes, elements, remove_mask) 
    elseif shape_type == "box" 
        remove_box!(shape, nodes, elements, remove_mask) 
    else 
        @warn "Unknown shape type for 'remove': $shape_type" 
    end 
end 
 
 
function make_sphere_elements(shape, nodes, dx, dy, dz) 
    if !haskey(shape,"center") || !haskey(shape,"diameter") 
        @warn "Sphere shape missing 'center' or 'diameter'; skipping." 
        return NTuple{8,Int}[] 
    end 
    @warn "make_sphere_elements does NOT generate new subdivided mesh so far." 
    return NTuple{8,Int}[] 
end 
 
function make_box_elements(shape, nodes, dx, dy, dz) 
    if !haskey(shape,"center") || !haskey(shape,"side") 
        @warn "Box shape missing 'center' or 'side'; skipping." 
        return NTuple{8,Int}[] 
    end 
    @warn "make_box_elements does NOT generate new subdivided mesh so far." 
    return NTuple{8,Int}[] 
end 
 
 
function remove_sphere!(shape::Dict, 
                        nodes::Matrix{Float32}, 
                        elements::Matrix{Int}, 
                        remove_mask::BitVector) 
    center = tuple(Float32.(shape["center"])...) 
    diam   = Float32(shape["diameter"]) 
    for e in 1:size(elements,1) 
        if !remove_mask[e] 
            c = element_centroid(e, nodes, elements) 
            if inside_sphere(c, center, diam) 
                remove_mask[e] = true 
            end 
        end 
    end 
end 
 
function remove_box!(shape::Dict, 
                     nodes::Matrix{Float32}, 
                     elements::Matrix{Int}, 
                     remove_mask::BitVector) 
    center = tuple(Float32.(shape["center"])...) 
    side   = Float32(shape["side"]) 
    for e in 1:size(elements,1) 
        if !remove_mask[e] 
            c = element_centroid(e, nodes, elements) 
            if inside_box(c, center, side) 
                remove_mask[e] = true 
            end 
        end 
    end 
end 
 
 
function element_centroid(e::Int, 
                          nodes::Matrix{Float32}, 
                          elements::Matrix{Int}) 
    conn = elements[e, :] 
    elem_nodes = nodes[conn, :] 
    centroid = sum(elem_nodes, dims=1) ./ 8.0f0 
    return vec(centroid) 
end 
 
end 
"// # FILE: .\MeshUtilities.jl";
module MeshUtilities 
 
export inside_sphere, inside_box, 
       check_element_quality, fix_inverted_elements!, 
       calculate_element_quality 
 
using ..Element   
 
using LinearAlgebra 
 
""" 
    inside_sphere(pt, center, diam) 
Return true if point `pt` is inside a sphere of diameter `diam` at `center`. 
""" 
function inside_sphere(pt::AbstractVector, center::Tuple{Float32,Float32,Float32}, diam::Float32) 
    r = diam / 2f0 
    return norm(pt .- collect(center)) <= r 
end 
 
""" 
    inside_box(pt, center, side) 
Return true if point `pt` is inside a cube of side `side` centered at `center`. 
""" 
function inside_box(pt::AbstractVector, center::Tuple{Float32,Float32,Float32}, side::Float32) 
    half = side / 2f0 
    return abs(pt[1] - center[1]) <= half && 
           abs(pt[2] - center[2]) <= half && 
           abs(pt[3] - center[3]) <= half 
end 
 
""" 
    check_element_quality(nodes, elements) -> poor_elements 
Mark which elements are degenerate, etc. 
""" 
function check_element_quality(nodes::Matrix{Float32}, elements::Matrix{Int}) 
    nElem = size(elements,1) 
    poor_elements = Int[] 
    for e in 1:nElem 
         
         
    end 
    return poor_elements 
end 
 
""" 
    fix_inverted_elements!(nodes, elements) -> (fixed_count, warning_count) 
Swap node ordering to fix negative Jacobians. 
""" 
function fix_inverted_elements!(nodes::Matrix{Float32}, elements::Matrix{Int}) 
     
    return (fixed_count, warning_count) 
end 
 
""" 
    calculate_element_quality(nodes, elements) 
Returns (aspect_ratios, min_jacobians) 
""" 
function calculate_element_quality(nodes::Matrix{Float32}, elements::Matrix{Int}) 
     
    return aspect_ratios, min_jacobians 
end 
 
end 
"// # FILE: .\Postprocessing.jl";

module Postprocessing

using JSON, Printf
using ..Mesh
using ..ExportVTK
import MarchingCubes: MC, march

export export_iteration_results, export_smooth_watertight_stl

"""
    get_smooth_nodal_densities(density, elements, nNodes)

Converts element-based density (constant per element) into node-based density
(linear variation) by averaging the values of elements connected to each node.
"""
function get_smooth_nodal_densities(density::Vector{Float32}, elements::Matrix{Int}, nNodes::Int)
    node_sums = zeros(Float32, nNodes)
    node_counts = zeros(Int, nNodes)
    
    nElem = length(density)
    
    
    @inbounds for e in 1:nElem
        rho = density[e]
        for i in 1:8
            node_idx = elements[e, i]
            node_sums[node_idx] += rho
            node_counts[node_idx] += 1
        end
    end
    
    
    nodal_density = zeros(Float32, nNodes)
    @inbounds for i in 1:nNodes
        if node_counts[i] > 0
            nodal_density[i] = node_sums[i] / Float32(node_counts[i])
        else
            nodal_density[i] = 0.0f0
        end
    end
    
    return nodal_density
end

"""
    trilinear_interpolate(vals, xd, yd, zd)

Interpolates value within a voxel defined by 8 corner values `vals`.
`vals` order corresponds to standard VTK/FEM hex ordering.
xd, yd, zd are normalized coordinates [0,1] within the voxel.
"""
@inline function trilinear_interpolate(vals, xd::Float32, yd::Float32, zd::Float32)
    c00 = vals[1]*(1f0-xd) + vals[2]*xd
    c01 = vals[4]*(1f0-xd) + vals[3]*xd
    c10 = vals[5]*(1f0-xd) + vals[6]*xd
    c11 = vals[8]*(1f0-xd) + vals[7]*xd

    c0 = c00*(1f0-yd) + c01*yd
    c1 = c10*(1f0-yd) + c11*yd

    return c0*(1f0-zd) + c1*zd
end

"""
    export_smooth_watertight_stl(density, geom, threshold, filename; subdivision_level=2)

Generates a high-quality, watertight STL.
1. Converts element density to nodal density.
2. Subdivides the grid (Trilinear interpolation) for smoothness.
3. Pads the grid with zeros to close boundaries.
"""
function export_smooth_watertight_stl(density::Vector{Float32}, geom, threshold::Float32, filename::String; subdivision_level::Int=2)
    println("Generating smooth watertight STL (Subdivision: $subdivision_level)...")
    
    
    dir_path = dirname(filename)
    if !isempty(dir_path) && !isdir(dir_path)
        mkpath(dir_path)
    end

    
    NX, NY, NZ = geom.nElem_x, geom.nElem_y, geom.nElem_z
    dx, dy, dz = geom.dx, geom.dy, geom.dz
    
    
    
    nodes_coarse, elements_coarse, _ = Mesh.generate_mesh(NX, NY, NZ; dx=dx, dy=dy, dz=dz)
    nNodes_coarse = size(nodes_coarse, 1)
    
    if length(density) != size(elements_coarse, 1)
        @warn "Density vector length ($(length(density))) does not match regenerated mesh ($(size(elements_coarse, 1))). STL export might be distorted."
    end
    
    nodal_density_coarse = get_smooth_nodal_densities(density, elements_coarse, nNodes_coarse)

    
    
    
    grid_coarse = reshape(nodal_density_coarse, (NX+1, NY+1, NZ+1))

    
    
    sub_NX = NX * subdivision_level
    sub_NY = NY * subdivision_level
    sub_NZ = NZ * subdivision_level

    
    pad = 1 
    fine_dim_x = sub_NX + 1 + 2*pad
    fine_dim_y = sub_NY + 1 + 2*pad
    fine_dim_z = sub_NZ + 1 + 2*pad

    
    sub_dx = dx / Float32(subdivision_level)
    sub_dy = dy / Float32(subdivision_level)
    sub_dz = dz / Float32(subdivision_level)

    
    fine_grid = zeros(Float32, fine_dim_x, fine_dim_y, fine_dim_z)
    
    
    x_coords = collect(Float32, range(-pad*sub_dx, step=sub_dx, length=fine_dim_x))
    y_coords = collect(Float32, range(-pad*sub_dy, step=sub_dy, length=fine_dim_y))
    z_coords = collect(Float32, range(-pad*sub_dz, step=sub_dz, length=fine_dim_z))

    println("  Interpolating coarse field to fine grid ($(fine_dim_x)x$(fine_dim_y)x$(fine_dim_z))...")
    
    
    
    Threads.@threads for k_f in (1+pad):(fine_dim_z-pad)
        for j_f in (1+pad):(fine_dim_y-pad)
            for i_f in (1+pad):(fine_dim_x-pad)
                
                
                ix = i_f - (1+pad)
                iy = j_f - (1+pad)
                iz = k_f - (1+pad)

                
                
                idx_x = div(ix, subdivision_level)
                idx_y = div(iy, subdivision_level)
                idx_z = div(iz, subdivision_level)

                
                if idx_x >= NX; idx_x = NX - 1; end
                if idx_y >= NY; idx_y = NY - 1; end
                if idx_z >= NZ; idx_z = NZ - 1; end

                
                c_i = idx_x + 1
                c_j = idx_y + 1
                c_k = idx_z + 1

                
                
                
                rem_x = ix - idx_x * subdivision_level
                rem_y = iy - idx_y * subdivision_level
                rem_z = iz - idx_z * subdivision_level
                
                xd = Float32(rem_x) / Float32(subdivision_level)
                yd = Float32(rem_y) / Float32(subdivision_level)
                zd = Float32(rem_z) / Float32(subdivision_level)

                
                v1 = grid_coarse[c_i,   c_j,   c_k]
                v2 = grid_coarse[c_i+1, c_j,   c_k]
                v3 = grid_coarse[c_i+1, c_j+1, c_k]
                v4 = grid_coarse[c_i,   c_j+1, c_k]
                v5 = grid_coarse[c_i,   c_j,   c_k+1]
                v6 = grid_coarse[c_i+1, c_j,   c_k+1]
                v7 = grid_coarse[c_i+1, c_j+1, c_k+1]
                v8 = grid_coarse[c_i,   c_j+1, c_k+1]

                
                vals = (v1, v2, v3, v4, v5, v6, v7, v8)

                
                val = trilinear_interpolate(vals, xd, yd, zd)
                fine_grid[i_f, j_f, k_f] = val
            end
        end
    end

    
    mc_struct = MC(
        fine_grid, 
        Int; 
        normal_sign=1,
        x=x_coords, 
        y=y_coords, 
        z=z_coords
    )

    march(mc_struct, threshold)

    vertices = mc_struct.vertices
    faces = mc_struct.triangles
    
    num_vertices = length(vertices)
    num_faces = length(faces)
    
    println("  Surface extracted: $num_vertices vertices, $num_faces triangles.")
    
    if num_faces == 0
        @warn "No isosurface found at threshold $threshold. STL file will be empty/invalid."
    end

    println("  Writing Binary STL to $filename...")

    
    try
        open(filename, "w") do io
            
            header_str = "Binary STL generated by HEXA Topology Optimization"
            header = rpad(header_str, 80, ' ')
            write(io, header)
            
            
            write(io, UInt32(num_faces))
            
            
            
            
            for face in faces
                v1 = vertices[face[1]]
                v2 = vertices[face[2]]
                v3 = vertices[face[3]]
                
                
                e1x, e1y, e1z = v2[1]-v1[1], v2[2]-v1[2], v2[3]-v1[3]
                e2x, e2y, e2z = v3[1]-v1[1], v3[2]-v1[2], v3[3]-v1[3]
                
                nx = e1y*e2z - e1z*e2y
                ny = e1z*e2x - e1x*e2z
                nz = e1x*e2y - e1y*e2x
                
                mag = sqrt(nx*nx + ny*ny + nz*nz)
                if mag > 1e-12
                    nx /= mag; ny /= mag; nz /= mag
                else
                    nx = 0.0f0; ny = 0.0f0; nz = 0.0f0
                end
                
                
                write(io, Float32(nx)); write(io, Float32(ny)); write(io, Float32(nz))
                
                
                write(io, Float32(v1[1])); write(io, Float32(v1[2])); write(io, Float32(v1[3]))
                
                write(io, Float32(v2[1])); write(io, Float32(v2[2])); write(io, Float32(v2[3]))
                
                write(io, Float32(v3[1])); write(io, Float32(v3[2])); write(io, Float32(v3[3]))
                
                
                write(io, UInt16(0))
            end
        end
        println("  Successfully exported STL.")
    catch e
        @error "Failed to save STL file: $e"
        println("Error details: ", e)
    end
end

function export_iteration_results(iter::Int, 
                                  base_name::String, 
                                  RESULTS_DIR::String, 
                                  nodes::Matrix{Float32}, 
                                  elements::Matrix{Int}, 
                                  U_full::Vector{Float32}, 
                                  F::Vector{Float32}, 
                                  bc_indicator::Matrix{Float32}, 
                                  principal_field::Matrix{Float32}, 
                                  vonmises_field::Vector{Float32}, 
                                  full_stress_voigt::Matrix{Float32}, 
                                  l1_stress_norm_field::Vector{Float32}, 
                                  density::Vector{Float32}, 
                                  E::Float32,
                                  geom)
      
    println("Exporting results for iteration $(iter)...") 
    iter_prefix = "iter_$(iter)_" 
    nElem = size(elements, 1) 

    
    json_filename = joinpath(RESULTS_DIR, "$(iter_prefix)$(base_name)_element_data.json") 
    element_data = [] 
    for e in 1:nElem 
        centroid_coords = Mesh.element_centroid(e, nodes, elements) 
        elem_info = Dict( 
            "element_id" => e, 
            "centroid" => centroid_coords, 
            "young_modulus" => E * density[e], 
            "von_mises_stress" => vonmises_field[e], 
            "l1_stress_norm" => l1_stress_norm_field[e], 
            "principal_stresses" => principal_field[:, e] 
        ) 
        push!(element_data, elem_info) 
    end 
      
    try 
        open(json_filename, "w") do f 
            write(f, JSON.json(element_data, 2)) 
        end 
    catch err 
        @error "Failed to write element JSON file: $err" 
    end 

    
    solution_filename = joinpath(RESULTS_DIR, "$(iter_prefix)$(base_name)_solution.vtu") 
    ExportVTK.export_solution(nodes, elements, U_full, F, bc_indicator, 
                              principal_field, vonmises_field, full_stress_voigt, 
                              l1_stress_norm_field; 
                              density=density,
                              scale=Float32(1.0),  
                              filename=solution_filename) 
      
    
    stl_filename = joinpath(RESULTS_DIR, "$(iter_prefix)$(base_name)_isosurface.stl")
    
    
    
    export_smooth_watertight_stl(density, geom, 0.3f0, stl_filename; subdivision_level=2)
end 

end
"// # FILE: .\Stress.jl";
module Stress 
 
using LinearAlgebra 
using ..Element 
export compute_stress_field 
 
""" 
    compute_element_stress(element_nodes, element_disp, E, nu) 
 
Computes the 3x3 stress tensor at the center of a hexahedral element via B*U => strain => stress. 
""" 
function compute_element_stress(element_nodes::Array{Float32,2}, 
                                 element_disp::Array{Float32,1}, 
                                 E::Float32, nu::Float32) 
    D = Element.material_matrix(E, nu) 
     
    xi, eta, zeta = Float32(0.0), Float32(0.0), Float32(0.0)  
    _, dN_dxi = Element.shape_functions(xi, eta,  
zeta) 
    J = transpose(dN_dxi)*element_nodes 
    detJ = det(J) 
    if detJ <= Float32(0.0)  
        error("Non-positive Jacobian!") 
    end 
    invJ = inv(J) 
    dN_dx = dN_dxi * transpose(invJ) 
 
     
    B = zeros(Float32, 6, 24) 
    for i in 1:8 
        idx = 3*(i-1)+1 
        dN_i = dN_dx[i, :] 
 
         
     
        B[1, idx]   = dN_i[1] 
        B[2, idx+1] = dN_i[2] 
        B[3, idx+2] = dN_i[3] 
 
         
        B[4, idx]   = dN_i[2]   
        B[4, idx+1] = dN_i[1] 
        B[5, idx+1] = dN_i[3]   
        B[5, idx+2] = dN_i[2] 
         
        B[6, idx]   = dN_i[3]   
        B[6, idx+2] = dN_i[1] 
    end 
 
    strain = B * element_disp 
    stress_voigt = D * strain 
 
    σ = zeros(Float32, 3, 3) 
    σ[1,1] = stress_voigt[1]   
    σ[2,2] = stress_voigt[2]   
    σ[3,3] = stress_voigt[3]   
    σ[1,2] = stress_voigt[4]; σ[2,1] = stress_voigt[4]   
    σ[2,3] = stress_voigt[5]; σ[3,2] = stress_voigt[5]   
    σ[1,3] = stress_voigt[6]; σ[3,1] = stress_voigt[6]   
    return σ 
end 
 
""" 
    compute_principal_and_vonmises(σ) 
 
Given a 3x3 stress tensor, returns (principal_stresses, von_mises). 
Principal are sorted descending. Von Mises uses standard formula. 
""" 
function compute_principal_and_vonmises(σ::Matrix{Float32}) 
    eigvals = eigen(σ).values 
     
    principal_stresses = sort(eigvals, rev=true) 
 
    σxx = σ[1,1] 
    σyy = σ[2,2] 
    σzz = σ[3,3] 
    σxy = σ[1,2] 
    σyz = σ[2,3] 
    σxz = σ[1,3] 
 
    vm = sqrt(Float32(0.5) * ((σxx-σyy)^2 + (σyy-σzz)^2 + (σzz-σxx)^2) + 
              Float32(3.0)*(σxy^2 + σyz^2 + σxz^2))  
 
    return principal_stresses, vm 
end 
 
""" 
    compute_stress_field(nodes, elements, U, E, nu, density) 
 
Loop over elements, compute: 
  - principal stresses (3 x nElem) 
  - von Mises (1 x nElem) 
  - full stress in Voigt form (6 x nElem) 
  - l1 stress norm (1 x nElem) <-- MODIFIED 
 
Returns (principal_field, vonmises_field, full_stress_voigt, l1_stress_norm_field). <-- MODIFIED 
""" 
function compute_stress_field(nodes, elements, U, E::Float32, nu::Float32, density::Vector{Float32}) 
    nElem = size(elements, 1) 
    principal_field     = zeros(Float32, 3, nElem) 
    vonmises_field    = zeros(Float32, nElem) 
    full_stress_voigt = zeros(Float32, 6,  
nElem) 
    l1_stress_norm_field = zeros(Float32, nElem)  
 
    for e in 1:nElem 
        conn = elements[e, :] 
        element_nodes = nodes[conn, :] 
 
         
        element_disp = zeros(Float32, 24) 
        for i in 1:8 
            global_node = conn[i] 
            element_disp[3*(i-1)+1 : 3*i] = U[3*(global_node-1)+1 : 3*global_node] 
         
        end 
 
        # Use the scaled Young's Modulus for this element 
        E_local = E * density[e] 
         
        σ = compute_element_stress(element_nodes, element_disp, E_local, nu) 
        (principal, vm) = compute_principal_and_vonmises(σ) 
 
         
        l1_norm = abs(principal[1]) + abs(principal[2]) + abs(principal[3]) 
         
 
        principal_field[:, e] = principal 
        vonmises_field[e]       = vm 
        l1_stress_norm_field[e] = l1_norm  
 
         
        full_stress_voigt[:, e] .= (σ[1,1], σ[2,2], σ[3,3], σ[1,2], σ[2,3], σ[1,3]) 
    end 
 
    return principal_field, vonmises_field, full_stress_voigt, l1_stress_norm_field  
end 
 
end 
"// # FILE: .\TopologyOptimization.jl";
# // # FILE: .\TopologyOptimization.jl";

module TopologyOptimization 

using LinearAlgebra
using SparseArrays
using Printf  
using Statistics 
using SuiteSparse 
using ..Element
using ..Mesh

export update_density!

mutable struct FilterCache
    is_initialized::Bool
    radius::Float32
    K_filter::SuiteSparse.CHOLMOD.Factor{Float32} 
    M_lumped::Vector{Float32}                      
    
    FilterCache() = new(false, 0.0f0)
end

const GLOBAL_FILTER_CACHE = FilterCache()

function reset_filter_cache!()
    GLOBAL_FILTER_CACHE.is_initialized = false
end

function assemble_helmholtz_system(nElem_x, nElem_y, nElem_z, dx, dy, dz, R)
    nNodes = (nElem_x + 1) * (nElem_y + 1) * (nElem_z + 1)
    nElem = nElem_x * nElem_y * nElem_z
    
    Ke_local, Me_local = Element.get_scalar_canonical_matrices(dx, dy, dz)
    
    entries_per_elem = 64 
    total_entries = nElem * entries_per_elem
    
    I_vec = Vector{Int32}(undef, total_entries)
    J_vec = Vector{Int32}(undef, total_entries)
    V_vec = Vector{Float32}(undef, total_entries)
    
    idx_counter = 0
    
    nx, ny, nz = nElem_x + 1, nElem_y + 1, nElem_z + 1
    
    Re_local = (R^2) .* Ke_local .+ Me_local
    
    for k in 1:nElem_z, j in 1:nElem_y, i in 1:nElem_x
        n1 = i      + (j-1)*nx      + (k-1)*nx*ny
        n2 = (i+1) + (j-1)*nx      + (k-1)*nx*ny
        n3 = (i+1) + j*nx          + (k-1)*nx*ny
        n4 = i      + j*nx          + (k-1)*nx*ny
        n5 = i      + (j-1)*nx      + k*nx*ny
        n6 = (i+1) + (j-1)*nx      + k*nx*ny
        n7 = (i+1) + j*nx          + k*nx*ny
        n8 = i      + j*nx          + k*nx*ny
        
        nodes = [n1, n2, n3, n4, n5, n6, n7, n8]
        
        for r in 1:8
            row = nodes[r]
            for c in 1:8
                col = nodes[c]
                idx_counter += 1
                I_vec[idx_counter] = row
                J_vec[idx_counter] = col
                V_vec[idx_counter] = Re_local[r, c]
            end
        end
    end
    
    K_global = sparse(I_vec, J_vec, V_vec, nNodes, nNodes)
    println("  Factorizing Helmholtz filter matrix...")
    return cholesky(K_global)
end

function apply_helmholtz_filter(field_elem::Vector{Float32}, F_fact, 
                                nElem_x, nElem_y, nElem_z, 
                                dx, dy, dz)
    
    nx, ny = nElem_x + 1, nElem_y + 1
    nNodes = (nElem_x + 1) * (nElem_y + 1) * (nElem_z + 1)
    
    elem_vol = dx * dy * dz
    nodal_weight = elem_vol / 8.0f0
    
    RHS = zeros(Float32, nNodes)
    
    idx_e = 1
    for k in 1:nElem_z, j in 1:nElem_y, i in 1:nElem_x
        val = field_elem[idx_e] * nodal_weight
        
        n1 = i      + (j-1)*nx      + (k-1)*nx*ny
        n2 = (i+1) + (j-1)*nx      + (k-1)*nx*ny
        n3 = (i+1) + j*nx          + (k-1)*nx*ny
        n4 = i      + j*nx          + (k-1)*nx*ny
        n5 = i      + (j-1)*nx      + k*nx*ny
        n6 = (i+1) + (j-1)*nx      + k*nx*ny
        n7 = (i+1) + j*nx          + k*nx*ny
        n8 = i      + j*nx          + k*nx*ny
        
        RHS[n1] += val; RHS[n2] += val; RHS[n3] += val; RHS[n4] += val;
        RHS[n5] += val; RHS[n6] += val; RHS[n7] += val; RHS[n8] += val;
        
        idx_e += 1
    end
    
    nodal_filtered = F_fact \ RHS
    
    filtered_elem = zeros(Float32, length(field_elem))
    
    idx_e = 1
    for k in 1:nElem_z, j in 1:nElem_y, i in 1:nElem_x
        n1 = i      + (j-1)*nx      + (k-1)*nx*ny
        n2 = (i+1) + (j-1)*nx      + (k-1)*nx*ny
        n3 = (i+1) + j*nx          + (k-1)*nx*ny
        n4 = i      + j*nx          + (k-1)*nx*ny
        n5 = i      + (j-1)*nx      + k*nx*ny
        n6 = (i+1) + (j-1)*nx      + k*nx*ny
        n7 = (i+1) + j*nx          + k*nx*ny
        n8 = i      + j*nx          + k*nx*ny
        
        sum_nodes = nodal_filtered[n1] + nodal_filtered[n2] + nodal_filtered[n3] + nodal_filtered[n4] +
                    nodal_filtered[n5] + nodal_filtered[n6] + nodal_filtered[n7] + nodal_filtered[n8]
        
        filtered_elem[idx_e] = sum_nodes / 8.0f0
        idx_e += 1
    end
    
    return filtered_elem
end

""" 
    update_density!(density, l1_stress_norm_field, ... config, [debug_flag])
    
Main optimization step with Helmholtz Filtering.
Returns max_change (Float32).
"""
function update_density!(density::Vector{Float32}, 
                         l1_stress_norm_field::Vector{Float32}, 
                         protected_elements_mask::BitVector, 
                         E::Float32, 
                         l1_stress_allowable::Float32, 
                         iter::Int, 
                         number_of_iterations::Int, 
                         original_density::Vector{Float32}, 
                         min_density::Float32,  
                         max_density::Float32, 
                         config::Dict,
                         debug_flag::Bool=false) 

    nElem = length(density)
    max_change = 0.0f0 
    
    opt_params = config["optimization_parameters"]
    geom_params = config["geometry"]

    R_init_perc = Float32(get(opt_params, "filter_R_init_perc", 0.0f0))
    R_interm_perc = Float32(get(opt_params, "filter_R_interm_perc", 0.0f0))
    R_final_perc = Float32(get(opt_params, "filter_R_final_perc", 0.0f0))
    R_interm_iter_perc = Float32(get(opt_params, "filter_R_interm_iter_perc", 50.0f0)) / 100.0f0
    
    R_manual = Float32(get(opt_params, "filter_radius", 0.0f0))
    R_length = Float32(R_manual) 
    
    if R_init_perc > 1e-6
        max_domain_dim = geom_params["max_domain_dim"]
        R_init_length = R_init_perc / 100.0f0 * max_domain_dim
        R_interm_length = R_interm_perc / 100.0f0 * max_domain_dim
        R_final_length = R_final_perc / 100.0f0 * max_domain_dim

        iter_interm = max(1, round(Int, R_interm_iter_perc * number_of_iterations))
        
        if iter <= iter_interm
            if iter_interm > 1
                t = (iter - 1) / (iter_interm - 1)
                R_length = R_init_length * (1 - t) + R_interm_length * t
            else
                R_length = R_init_length
            end
        else 
            if number_of_iterations > iter_interm
                t = (iter - iter_interm) / (number_of_iterations - iter_interm)
                R_length = R_interm_length * (1 - t) + R_final_length * t
            else
                R_length = R_interm_length 
            end
        end
        
        R_length = R_length / 2.5f0
    end
    
    filtered_l1_stress = l1_stress_norm_field
    
    if R_length > 1e-4
        nElem_x = Int(geom_params["nElem_x_computed"]) 
        nElem_y = Int(geom_params["nElem_y_computed"])
        nElem_z = Int(geom_params["nElem_z_computed"])
        dx = Float32(geom_params["dx_computed"])
        dy = Float32(geom_params["dy_computed"])
        dz = Float32(geom_params["dz_computed"])

        if !GLOBAL_FILTER_CACHE.is_initialized || abs(GLOBAL_FILTER_CACHE.radius - R_length) > 1e-5
            println("  [Filter] Re-assembling Helmholtz matrix (R changed to $R_length)...")
            fact = assemble_helmholtz_system(nElem_x, nElem_y, nElem_z, dx, dy, dz, R_length)
            GLOBAL_FILTER_CACHE.K_filter = fact
            GLOBAL_FILTER_CACHE.radius = R_length
            GLOBAL_FILTER_CACHE.is_initialized = true
        end
        
        @printf("Applying Helmholtz PDE filter (Length Scale=%.4f)...\n", R_length)
        filtered_l1_stress = apply_helmholtz_filter(l1_stress_norm_field, 
                                                    GLOBAL_FILTER_CACHE.K_filter, 
                                                    nElem_x, nElem_y, nElem_z, 
                                                    dx, dy, dz)
    end
    
    
    for e in 1:nElem
        if !protected_elements_mask[e] 
            current_l1_stress = filtered_l1_stress[e]
            
            new_density_value = (current_l1_stress / l1_stress_allowable) / E
            
            old_val = density[e]
            new_val = clamp(new_density_value, min_density, max_density)
            
            density[e] = new_val
            
            diff = abs(new_val - old_val)
            if diff > max_change
                max_change = diff
            end
        end
    end
    
    progress = Float32(iter) / Float32(number_of_iterations)
    current_threshold = Float32(0.95) * progress
    @printf("Applying moving threshold: density < %.4f\n", current_threshold)
    
    num_removed = 0
    for e in 1:nElem
        if !protected_elements_mask[e]
            if density[e] < current_threshold
                density[e] = min_density 
                num_removed += 1
            end
        end
    end
    println("Set $num_removed non-protected elements to 'soft'.")
    
    for e in 1:nElem
        if protected_elements_mask[e]
            density[e] = original_density[e]
        end
    end
    
    println("Density update complete. Max change: $max_change")
    return max_change
end

end
"// # FILE: .\concatenate_code.jl";


# into a single file named 'concatenated_output.txt'.





# We use a string literal format: " // # FILE: <path> ";

const FILE_SEPARATOR_START = "\"// # FILE: "
const FILE_SEPARATOR_END   = "\";"
const OUTPUT_FILENAME = "concatenated_output.txt"

using FilePathsBase 

function remove_comments(content::String)
    
    # This handles single-line comments starting with '#' *if* they are not inside double-quotes.
   
    # Simple regex to find a '#' not preceded by a double-quote, and capture everything after.
    # This is still a simplification (doesn't handle escaped quotes or triple quotes)
    
   
    lines = split(content, '\n')
    cleaned_lines = String[]
   
    for line in lines
        
        if occursin('\'', line)
             push!(cleaned_lines, line) 
             continue
        end

        # Find the first '#' not preceded by an unescaped double quote (complex to do simply)
        
        if !occursin('"', line)
            comment_start = findfirst('#', line)
           
            if comment_start !== nothing
                
                
                cleaned_part = line[1:comment_start-1]
                push!(cleaned_lines, cleaned_part)
                continue 
            end
        end

        # If no '#' or if a double quote was found, or if it was handled above:
        push!(cleaned_lines, line)
    end
   
    return join(cleaned_lines, '\n')
end


function concatenate_files()
    
    try
        global my_full_path = abspath(@__FILE__)
    catch
        println("Warning: Could not determine script path. Running from REPL? Assuming 'concatenate_files.jl' in current dir.")
        global my_full_path = abspath("concatenate_files.jl")
    end

    output_full_path = abspath(OUTPUT_FILENAME)
   
    
    excluded_extensions = Set(["txt", "vtk", "md", "1html", "vtu", "json", "1yaml", "yml"])
   
    
    excluded_folders = Set([".git", ".vscode", "xxSOLVER", "RESULTS", "assets", "1PREPOST"])
    

    
    excluded_filenames = Set([".gitignore", "Project.toml", "Manifest.toml", "README.md", "1concatenate_files.jl", "restore_files.jl", OUTPUT_FILENAME])
   
    
    try
        open(output_full_path, "w") do outfile
            println("Starting concatenation... Output will be in '$OUTPUT_FILENAME'")
            println("Excluding extensions: $excluded_extensions")
            println("Excluding folders: $excluded_folders")
            println("Excluding filenames: $excluded_filenames")
           
            # Walk the directory tree starting from the current folder "."
            for (root, dirs, files) in walkdir(".")
               
                # --- Filter 'dirs' in-place ---
                filter!(d -> d ∉ excluded_folders, dirs)
               
                for file in files
                    full_path = abspath(joinpath(root, file))
                    relative_path = joinpath(root, file)
                   
                    
                    basename, ext = splitext(file)
                    cleaned_ext = lstrip(ext, '.')
                   
                    
                    if full_path == my_full_path || full_path == output_full_path
                        println("Skipping script/output file: $full_path")
                        continue
                    end
                    if file in excluded_filenames
                        println("Skipping file by name: $full_path")
                        continue
                    end
                    if cleaned_ext in excluded_extensions
                        println("Skipping file by extension ($cleaned_ext): $full_path")
                        continue
                    end
                    
                   
                    println("Processing: $relative_path")
                   
                    
                    # Format: "// # FILE: <relative_path>";
                    write(outfile, FILE_SEPARATOR_START, relative_path, FILE_SEPARATOR_END, "\n")
                   
                    
                    try
                        file_content = read(full_path, String)
                       
                        
                        if cleaned_ext == "jl"
                            file_content = remove_comments(file_content)
                        end
                       
                        write(outfile, file_content)
                       
                        
                        if !endswith(file_content, '\n')
                            write(outfile, "\n")
                        end
                       
                    catch e
                        # This handles non-text/binary files that can't be read as String
                        write(outfile, "\n# !!! ERROR: Could not read file (possibly binary or bad encoding or comment removal failure).\n")
                        write(outfile, "# !!! Error details: $e\n")
                    end
                end
            end
        end
       
        println("Concatenation complete! All files saved to '$OUTPUT_FILENAME'")
       
    catch e
        println("An error occurred during file operations: $e")
    end
end


concatenate_files()
"// # FILE: .\config.yaml";
# Configuration file for HEXA FEM Topology Optimization, controlling geometry, material, optimization goals, and solver hyperparameters.

  # Domain dimension in the X direction (meters).
  # Domain dimension in the Y direction (meters).
  # Domain dimension in the Z direction (meters).
  # Target total number of elements. The mesh generator calculates N_x, N_y, N_z based on dimension ratios.
  # Shapes define fixed regions (void or solid) that are excluded from optimization.
geometry:
  length_x: 60 # Domain dimension in the X direction (meters).
  length_y: 20 # Domain dimension in the Y direction (meters).
  length_z: 20 # Domain dimension in the Z direction (meters).
  target_elem_count: 100000 # Target total number of elements. The mesh generator calculates N_x, N_y, N_z based on dimension ratios.
  shape_notes: Shapes define fixed regions (void or solid) that are excluded from optimization.
  sphere1:
    # Geometric type: 'sphere' or 'box'.
    type: sphere
    # [X, Y, Z] coordinate of the shape center.
    center:
      - 12.510000228881836
      - 18.41960906982422
      - 1.17731511592865
    # Diameter of the sphere.
    diameter: 8
    # Fixed density type: 'remove' (min_density) or 'add' (max_density_initial_add).
    action: remove
  sphere2:
    # Geometric type: 'sphere' or 'box'.
    type: sphere
    # [X, Y, Z] coordinate of the shape center.
    center:
      - 60.381900787353516
      - -0.06934642046689987
      - 9.764435768127441
    # Diameter of the sphere.
    diameter: 4
    # Fixed density type: 'remove' (min_density) or 'add' (max_density_initial_add).
    action: add
  sphere3:
    # Geometric type: 'sphere' or 'box'.
    type: sphere
    # [X, Y, Z] coordinate of the shape center.
    center:
      - 34.29201126098633
      - 5
      - 2.426476240158081
    # Diameter of the sphere.
    diameter: 4
    # Fixed density type: 'remove' (min_density) or 'add' (max_density_initial_add).
    action: remove
  box2:
    # Geometric type: 'sphere' or 'box'.
    type: box
    # [X, Y, Z] coordinate of the shape center.
    center:
      - 45.06150817871094
      - 8.946874618530273
      - 1.094521164894104
    # Side length of the cube/box.
    side: 4
    # Fixed density type: 'remove' (min_density) or 'add' (max_density_initial_add).
    action: remove
  box1:
    # Geometric type: 'sphere' or 'box'.
    type: box
    # [X, Y, Z] coordinate of the shape center.
    center:
      - 28
      - 7
      - 2.3188514709472656
    # Side length of the cube/box.
    side: 2
    # Fixed density type: 'remove' (min_density) or 'add' (max_density_initial_add).
    action: add

# Defines fixed displacement constraints on nodes matching the location criteria.
boundary_conditions:
  - location:
      - 0
      - ':'
      - ':'
    # Constrained Degrees of Freedom: 1=X translation, 2=Y translation, 3=Z translation.
    DoFs:
      - 1
      - 2
      - 3

# Defines concentrated forces applied to nodes matching the location criteria.
external_forces:
  - location:
      - 1
      - 0
      - 0.5
    # Force vector [Fx, Fy, Fz] (applied as total force, distributed if using 'location').
    F:
      - 0
      - 10
      - 0
  - location:
      - 1
      - 0
      - 0.5
    # Force vector [Fx, Fy, Fz] (applied as total force, distributed if using 'location').
    F:
      - 0
      - 0
      - 10
# Base material properties for solid elements.
material:
  E: 1 # Young's Modulus (base value).
  nu: 0.3 # Poisson's Ratio.
number_of_iterations: 30
l1_stress_allowable: 1

# Parameters related to the SIMP and density update rule.
optimization_parameters:
  min_density: 0.0001 # Minimum allowable element density (rho_min). Higher values increase stability but introduce 'gray' elements. Recommended: 0.001 to 0.01.
  max_density_initial_add: 10 # Initial density for 'add' shapes (controls initial fixed stiffness). Typically >= 1.0.
  density_clamp_max: 1 # Maximum value for element density. Usually 1.0.
  filter_R_init_perc: 2
  filter_R_interm_perc: 1
  filter_R_final_perc: 0.25
  filter_R_interm_iter_perc: 80
  filter_radius: 0

# Parameters for selecting the solver type, tolerance, and numerical stability tuning.
solver_parameters:
  solver_type: gpu # Solver type: 'direct' (small problems), 'matrix_free' (CPU iterative), or 'gpu' (GPU iterative).
  tolerance: 1.e-7 # CG/Krylov solver convergence tolerance (Relative Residual Norm). Recommended 1e-6 or lower.
  max_iterations: 30000 # Maximum number of iterations allowed for the chosen iterative solver (CG/Krylov).
  diagonal_shift_factor: 1.e-7 # Regularization factor (delta) applied as a fraction of max diagonal element. Critical for ill-conditioned matrices. Recommended 1e-6 to 1e-4.
  gpu_method: krylov # If solver_type is 'gpu': 'native' (CUDA CG) or 'krylov' (Krylov.jl wrapper).
  krylov_solver: cg # If gpu_method is 'krylov': Specify algorithm: 'cg', 'minres', or 'bicgstab'.
"// # FILE: .\marching.jl";
using JSON3 
using Statistics 
using Printf 
import MarchingCubes: MC, march 
 
const LX = 60.0f0 
const LY = 20.0f0 
const LZ = 0.1f0 
 
const JSON_FILE_NAME = "iter_20_config_element_data.json" 
const JSON_FILE_PATH = joinpath(@__DIR__, "RESULTS", JSON_FILE_NAME)  
 
const ISOSURFACE_DENSITY = 0.8f0 
const STL_OUTPUT_FILE = "topopt_isosurface_80.stl" 
 
function infer_mesh_and_load_density(filepath::String) 
     
    println("1. Loading element data and inferring mesh structure from: $filepath") 
     
    if !isfile(filepath) 
        error("File not found at path: $filepath. Ensure the optimization run completed successfully and the 'RESULTS' folder is correctly placed relative to this script.") 
    end 
 
    data = JSON3.read(read(filepath, String)) 
     
    n_total_el_from_file = length(data) 
 
    if n_total_el_from_file < 2 
        error("Not enough elements in the result file to infer mesh size.") 
    end 
 
    density_field = Dict{Int, Float32}() 
     
    first_el_centroid = data[1]["centroid"] 
    dx, dy, dz = 0.0f0, 0.0f0, 0.0f0 
     
    if length(data) >= 2 
        second_el_centroid = data[2]["centroid"] 
        dx = abs(second_el_centroid[1] - first_el_centroid[1]) 
    end 
 
    cy1 = first_el_centroid[2] 
    for i = 2:length(data) 
        cy_i = data[i]["centroid"][2] 
        if abs(cy_i - cy1) > 1e-6  
            dy = abs(cy_i - cy1) 
            break 
        end 
    end 
     
    cz1 = first_el_centroid[3] 
    for i = 2:length(data) 
        cz_i = data[i]["centroid"][3] 
        if abs(cz_i - cz1) > 1e-6  
            dz = abs(cz_i - cz1) 
            break 
        end 
    end 
 
    if dx < 1e-6 
        dx_final = LX 
        NX = 1 
    else 
        NX = round(Int, LX / dx) 
        dx_final = LX / NX  
    end 
 
    if dy < 1e-6 
        dy_final = LY 
        NY = 1 
    else 
        NY = round(Int, LY / dy) 
        dy_final = LY / NY 
    end 
     
    if dz < 1e-6 
        dz_final = LZ 
        NZ = 1 
    else 
        NZ = round(Int, LZ / dz) 
        dz_final = LZ / NZ 
    end 
 
    inferred_n_total_el = NX * NY * NZ 
 
    if inferred_n_total_el != length(data) 
        @warn "Inferred element count ($inferred_n_total_el) does not match file count ($(length(data))). Using file count for array size." 
    end 
     
    println("   Inferred mesh dimensions: $(NX) x $(NY) x $(NZ) elements.") 
    println("   Element size (dx, dy, dz): $(@sprintf("%.6f", dx_final)), $(@sprintf("%.6f", dy_final)), $(@sprintf("%.6f", dz_final))") 
 
    for elem in data 
        density = elem["young_modulus"] 
        density_field[elem["element_id"]] = Float32(density) 
    end 
     
    sorted_densities = [density_field[i] for i in 1:length(data)] 
 
    x_coords = collect(Float32, range(0.0f0, stop=LX, length=NX + 1)) 
    y_coords = collect(Float32, range(0.0f0, stop=LY, length=NY + 1)) 
    z_coords = collect(Float32, range(0.0f0, stop=LZ, length=NZ + 1)) 
 
    return sorted_densities, NX, NY, NZ, x_coords, y_coords, z_coords 
end 
 
function prepare_density_grid(densities::Vector{Float32}, NX::Int, NY::Int, NZ::Int) 
    println("2. Preparing 3D density grid...") 
     
    node_densities = zeros(Float32, NX + 1, NY + 1, NZ + 1) 
     
    cell_densities = reshape(densities, NX, NY, NZ) 
     
    for k in 1:NZ 
        for j in 1:NY 
            for i in 1:NX 
                node_densities[i, j, k] = cell_densities[i, j, k] 
            end 
        end 
    end 
 
    println("   Node grid of dimensions $(NX+1)x$(NY+1)x$(NZ+1) created from cell data.") 
    return node_densities 
end 
 
function run_marching_cubes(density_grid::Array{Float32, 3}, x_coords::Vector{Float32}, y_coords::Vector{Float32}, z_coords::Vector{Float32}) 
    println("3. Running Marching Cubes (Isosurface Extraction) at threshold $(ISOSURFACE_DENSITY)...") 
     
    mc_struct = MC( 
        density_grid,  
        Int;  
        normal_sign=1, 
        x=x_coords,  
        y=y_coords,  
        z=z_coords 
    ) 
 
    march(mc_struct, ISOSURFACE_DENSITY) 
 
    vertices = mc_struct.vertices 
    triangles = mc_struct.triangles 
     
    num_vertices = length(vertices) 
    num_faces = length(triangles) 
     
    @printf("   Surface extracted: %d vertices, %d faces.\n", num_vertices, num_faces) 
     
    return (vertices, triangles) 
end 
 
function export_to_stl(result::Tuple) 
    vertices = result[1] 
    faces = result[2] 
     
    println("4. Exporting surface to ASCII STL file: $STL_OUTPUT_FILE") 
     
    open(STL_OUTPUT_FILE, "w") do io 
        write(io, "solid topopt_model\n") 
         
        for face in faces 
            v1 = vertices[face[1]] 
            v2 = vertices[face[2]] 
            v3 = vertices[face[3]] 
             
            e1 = (v2[1]-v1[1], v2[2]-v1[2], v2[3]-v1[3]) 
            e2 = (v3[1]-v1[1], v3[2]-v1[2], v3[3]-v1[3]) 
             
            nx = e1[2]*e2[3] - e1[3]*e2[2] 
            ny = e1[3]*e2[1] - e1[1]*e2[3] 
            nz = e1[1]*e2[2] - e1[2]*e2[1] 
             
            mag = sqrt(nx^2 + ny^2 + nz^2) 
            if mag > 1e-12 
                nx /= mag 
                ny /= mag 
                nz /= mag 
            else 
                nx, ny, nz = 0.0, 0.0, 0.0 
            end 
             
            @printf(io, "  facet normal %e %e %e\n", nx, ny, nz) 
            write(io, "    outer loop\n") 
             
            @printf(io, "      vertex %e %e %e\n", v1[1], v1[2], v1[3]) 
            @printf(io, "      vertex %e %e %e\n", v2[1], v2[2], v2[3]) 
            @printf(io, "      vertex %e %e %e\n", v3[1], v3[2], v3[3]) 
             
            write(io, "    endloop\n") 
            write(io, "  endfacet\n") 
        end 
         
        write(io, "endsolid topopt_model\n") 
    end 
     
    println("   Export complete. The file is ready for your CAD/viewer software.") 
end 
 
 
function main_postprocess() 
    try 
        densities, NX, NY, NZ, x_coords, y_coords, z_coords = infer_mesh_and_load_density(JSON_FILE_PATH) 
         
        density_grid = prepare_density_grid(densities, NX, NY, NZ) 
         
        surface_result = run_marching_cubes(density_grid, x_coords, y_coords, z_coords) 
         
        export_to_stl(surface_result) 
         
    catch e 
        @error "An error occurred during post-processing." exception=(e, catch_backtrace()) 
    end 
end 
 
main_postprocess() 
"// # FILE: .\restore.jl";


# the original file and directory structure into a new folder named 'restored_directory'.


const SEPARATOR_START = "\"// # FILE: "
const SEPARATOR_END   = "\";"

const INPUT_FILENAME = "concatenated_output.txt"
const RESTORE_DIR = "restored_directory"

function restore_files()
    if !isfile(INPUT_FILENAME)
        println("Error: Input file '$INPUT_FILENAME' not found in the current directory.")
        return
    end

    println("Starting restoration from '$INPUT_FILENAME'...")
    
    
    local content
    try
        content = read(INPUT_FILENAME, String)
    catch e
        println("Error reading input file: $e")
        return
    end

    
    
    
    parts = split(content, SEPARATOR_START)
    
    
    if isdir(RESTORE_DIR)
        println("Warning: Restoration directory '$RESTORE_DIR' already exists. Files might be overwritten.")
    else
        mkdir(RESTORE_DIR)
        println("Created restoration directory: '$RESTORE_DIR'")
    end

    
    count = 0
    for part in parts
        # We look for the SEPARATOR_END (";) to identify if this block is valid
        
        end_marker_range = findfirst(SEPARATOR_END, part)

        if end_marker_range === nothing
            
            # It's likely the text before the very first file (preamble).
            continue
        end

        # Extract the relative path (everything before the ";)
        
        path_end_index = prevind(part, end_marker_range.start)
        relative_path = strip(part[1:path_end_index])
        
        if isempty(relative_path)
            println("Warning: Found empty file path. Skipping block.")
            continue
        end

        # Extract the content (everything after the ";)
        content_start_index = nextind(part, end_marker_range.stop)
        file_content = part[content_start_index:end]

        
        
        if startswith(file_content, "\n")
            file_content = file_content[2:end]
        elseif startswith(file_content, "\r\n") # Windows safety
            file_content = file_content[3:end]
        end
        
        
        restored_full_path = joinpath(RESTORE_DIR, relative_path)
        
        
        restored_dir = dirname(restored_full_path)
        
        # 5. Create the required sub-directories if they don't exist
        if !isdir(restored_dir)
            try
                mkpath(restored_dir) 
                println("Created directory: $restored_dir")
            catch e
                println("Error creating directory $restored_dir: $e")
                continue
            end
        end

        
        try
            open(restored_full_path, "w") do outfile
                write(outfile, file_content)
            end
            println("Restored file: $relative_path")
            count += 1
        catch e
            println("Error writing file $relative_path: $e")
        end
    end

    println("Restoration complete! $count files restored to '$RESTORE_DIR'.")
end


restore_files()
"// # FILE: .\ARCHIVE\config.yaml";
# Configuration file for HEXA FEM Topology Optimization, controlling geometry, material, optimization goals, and solver hyperparameters. 
 
  # Domain dimension in the X direction (meters). 
  # Domain dimension in the Y direction (meters). 
  # Domain dimension in the Z direction (meters). 
  # Target total number of elements. The mesh generator calculates N_x, N_y, N_z based on dimension ratios. 
  # Shapes define fixed regions (void or solid) that are excluded from optimization. 
geometry: 
  length_x: 60 # Domain dimension in the X direction (meters). 
  length_y: 20 # Domain dimension in the Y direction (meters). 
  length_z: 0.1 # Domain dimension in the Z direction (meters). 
  target_elem_count: 200000 # Target total number of elements. The mesh generator calculates N_x, N_y, N_z based on dimension ratios. 
  shape_notes: Shapes define fixed regions (void or solid) that are excluded from optimization. 
  sphere1: 
    # Geometric type: 'sphere' or 'box'. 
    type: sphere 
    # [X, Y, Z] coordinate of the shape center. 
    center: 
      - 12.510000228881836 
      - 5 
      - -13.991933822631836 
    # Diameter of the sphere. 
    diameter: 8 
    # Fixed density type: 'remove' (min_density) or 'add' (max_density_initial_add). 
    action: remove 
  sphere2: 
    # Geometric type: 'sphere' or 'box'. 
    type: sphere 
    # [X, Y, Z] coordinate of the shape center. 
    center: 
      - 9 
      - 5 
      - -6.200438976287842 
    # Diameter of the sphere. 
    diameter: 4 
    # Fixed density type: 'remove' (min_density) or 'add' (max_density_initial_add). 
    action: add 
  sphere3: 
    # Geometric type: 'sphere' or 'box'. 
    type: sphere 
    # [X, Y, Z] coordinate of the shape center. 
    center: 
      - 34.29201126098633 
      - 5 
      - -7.112380504608154 
    # Diameter of the sphere. 
    diameter: 4 
    # Fixed density type: 'remove' (min_density) or 'add' (max_density_initial_add). 
    action: remove 
  box2: 
    # Geometric type: 'sphere' or 'box'. 
    type: box 
    # [X, Y, Z] coordinate of the shape center. 
    center: 
      - 45.06150817871094 
      - 8.946874618530273 
      - -10.001893997192383 
    # Side length of the cube/box. 
    side: 4 
    # Fixed density type: 'remove' (min_density) or 'add' (max_density_initial_add). 
    action: remove 
  box1: 
    # Geometric type: 'sphere' or 'box'. 
    type: box 
    # [X, Y, Z] coordinate of the shape center. 
    center: 
      - 28 
      - 7 
      - -9.824102401733398 
    # Side length of the cube/box. 
    side: 2 
    # Fixed density type: 'remove' (min_density) or 'add' (max_density_initial_add). 
    action: add 
 
# Defines fixed displacement constraints on nodes matching the location criteria. 
boundary_conditions: 
  - location: 
      - 0 
      - ':' 
      - ':' 
    # Constrained Degrees of Freedom: 1=X translation, 2=Y translation, 3=Z translation. 
    DoFs: 
      - 1 
      - 2 
      - 3 
 
# Defines concentrated forces applied to nodes matching the location criteria. 
external_forces: 
  - location: 
      - 1 
      - 0 
      - 0 
    # Force vector [Fx, Fy, Fz] (applied as total force, distributed if using 'location'). 
    F: 
      - 0 
      - 10 
      - 0 
 
# Base material properties for solid elements. 
material: 
  E: 1 # Young's Modulus (base value). 
  nu: 0.3 # Poisson's Ratio. 
number_of_iterations: 20 
l1_stress_allowable: 30 
 
# Parameters related to the SIMP and density update rule. 
optimization_parameters: 
  min_density: 0.001 # Minimum allowable element density (rho_min). Higher values increase stability but introduce 'gray' elements. Recommended: 0.001 to 0.01. 
  max_density_initial_add: 10 # Initial density for 'add' shapes (controls initial fixed stiffness). Typically >= 1.0. 
  density_clamp_max: 1 # Maximum value for element density. Usually 1.0. 
  filter_radius: 5 # The Filter Radius (R) - Set to 0.0 to auto-calculate based on mesh size, or specify a value (e.g., 3x element size) 
 
# Parameters for selecting the solver type, tolerance, and numerical stability tuning. 
solver_parameters: 
  solver_type: gpu # Solver type: 'direct' (small problems), 'matrix_free' (CPU iterative), or 'gpu' (GPU iterative). 
  tolerance: 1e-6 # CG/Krylov solver convergence tolerance (Relative Residual Norm). Recommended 1e-6 or lower. 
  max_iterations: 30000 # Maximum number of iterations allowed for the chosen iterative solver (CG/Krylov). 
  diagonal_shift_factor: 1e-8 # Regularization factor (delta) applied as a fraction of max diagonal element. Critical for ill-conditioned matrices. Recommended 1e-6 to 1e-4. 
  gpu_method: krylov # If solver_type is 'gpu': 'native' (CUDA CG) or 'krylov' (Krylov.jl wrapper). 
  krylov_solver: cg # If gpu_method is 'krylov': Specify algorithm: 'cg', 'minres', or 'bicgstab'. 
"// # FILE: .\PREPOST\post.html";
<!DOCTYPE html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>Babylon.js FEM Stress Visualizer (Instanced)</title> 
    <script src="https://cdn.babylonjs.com/babylon.js"></script> 
    <script src="https://cdn.tailwindcss.com"></script> 
    <style> 
        /* Ensure canvas fills the background */ 
        html, body { 
            width: 100%; 
            height: 100%; 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
        } 
        #renderCanvas { 
            width: 100%; 
            height: 100%; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 0; /* Behind the UI */ 
            touch-action: none; 
        } 
        #uiPanel { 
            position: absolute; 
            top: 1.5rem; 
            left: 1.5rem; 
            z-index: 10; 
        } 
    </style> 
</head> 
<body class="bg-gray-900"> 
 
    <canvas id="renderCanvas"></canvas> 
 
    <div id="uiPanel" class="bg-white/90 backdrop-blur-sm p-4 rounded-lg shadow-xl w-80 space-y-3"> 
        <h1 class="text-xl font-bold text-gray-800">Stress Visualizer</h1> 
         
        <div> 
            <label for="fileInput" class="block text-sm font-medium text-gray-700">1. Load Element Data (.json)</label> 
            <input type="file" id="fileInput" accept=".json" class="mt-1 block w-full text-sm text-gray-500 
                file:mr-4 file:py-2 file:px-4 
                file:rounded-md file:border-0 
                file:text-sm file:font-semibold 
                file:bg-blue-50 file:text-blue-700 
                hover:file:bg-blue-100 cursor-pointer"/> 
        </div> 
 
        <div> 
            <label for="dataFieldSelect" class="block text-sm font-medium text-gray-700">2. Select Data Field</label> 
            <select id="dataFieldSelect" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2"> 
            </select> 
        </div> 
 
        <div class="space-y-2"> 
            <h2 class="text-sm font-medium text-gray-700">3. Adjust Color Scale Limits</h2> 
            <div class="flex gap-2"> 
                <div> 
                    <label for="minStress" class="block text-xs font-medium text-gray-600">Min Value</label> 
                    <input type="text" id="minStress" value="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2"> 
                </div> 
                <div> 
                    <label for="maxStress" class="block text-xs font-medium text-gray-600">Max Value</label> 
                    <input type="text" id="maxStress" value="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2"> 
                </div> 
            </div> 
            <button id="applyButton" class="w-full bg-blue-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-150"> 
                Apply Limits 
            </button> 
        </div> 
 
        <div class="border-t pt-3 space-y-2"> 
            <label for="densitySlider" class="block text-sm font-medium text-gray-700">4. Visibility Threshold (Density)</label> 
            <div class="flex items-center gap-2"> 
                <input type="range" id="densitySlider" min="0" max="1" value="0" step="0.01" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"> 
                <span id="densityValue" class="text-sm font-mono w-12 text-right">0.00</span> 
            </div> 
        </div> 
        <div id="status" class="text-sm text-gray-600 border-t pt-2"> 
            Please load a file. 
        </div> 
    </div> 
 
    <script> 
        // Get the canvas element 
        const canvas = document.getElementById('renderCanvas'); 
        // Get UI elements 
        const fileInput = document.getElementById('fileInput'); 
        const dataFieldSelect = document.getElementById('dataFieldSelect'); 
        const minInput = document.getElementById('minStress'); 
        const maxInput = document.getElementById('maxStress'); 
        const applyButton = document.getElementById('applyButton'); 
        const statusEl = document.getElementById('status'); 
        // --- NEW SLIDER ELEMENTS --- 
        const densitySlider = document.getElementById('densitySlider'); 
        const densityValue = document.getElementById('densityValue'); 
 
        // --- Global Variables --- 
        let engine; 
        let scene; 
        let allElementData = []; 
        let availableFields = []; 
        let currentDataField = 'von_mises_stress'; // Default 
        let dataMinStress = 0; 
        let dataMaxStress = 1; 
        let currentMin = 0; 
        let currentMax = 1; 
        let rootNode = null; // A parent for all cubes 
        let templateBox = null; // The master template mesh 
        let ground = null; 
        let groundMat = null; 
        let elementSize = { dx: 0.1, dy: 0.1, dz: 0.1 }; 
        let currentDensityThreshold = 0.0; // --- NEW GLOBAL FOR SLIDER --- 
 
        /** 
         * Initializes the Babylon.js engine and scene. 
         */ 
        function initBabylon() { 
            engine = new BABYLON.Engine(canvas, true); 
            scene = new BABYLON.Scene(engine); 
            scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.15, 1); 
 
            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 50, new BABYLON.Vector3(0, 5, 0), scene); 
            camera.attachControl(canvas, true); 
            camera.wheelPrecision = 50; 
 
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene); 
            light.intensity = 0.8; 
 
            ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 100, height: 100}, scene); 
            groundMat = new BABYLON.StandardMaterial("groundMat", scene); 
            groundMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3); 
            groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1); 
            ground.material = groundMat; 
 
            engine.runRenderLoop(() => { 
                scene.render(); 
            }); 
 
            window.addEventListener('resize', () => { 
                engine.resize(); 
            }); 
        } 
 
        /** 
         * Handles the file input event. 
         */ 
        function handleFileLoad(event) { 
            const file = event.target.files[0]; 
            if (!file) return; 
 
            statusEl.textContent = 'Loading file...'; 
            const reader = new FileReader(); 
 
            reader.onload = (e) => { 
                try { 
                    allElementData = JSON.parse(e.target.result); 
                    if (!Array.isArray(allElementData) || allElementData.length === 0) { 
                        throw new Error("Invalid or empty data array."); 
                    } 
                    if (!allElementData[0].hasOwnProperty('centroid') || !allElementData[0].hasOwnProperty('young_modulus')) { 
                        throw new Error("JSON items are missing 'centroid' or 'young_modulus' key."); 
                    } 
                     
                    discoverAvailableFields(); 
                    populateDropdown(); 
 
                    statusEl.textContent = `Loaded ${allElementData.length} elements.`; 
                     
                    // Reset slider 
                    densitySlider.value = 0; 
                    densityValue.textContent = "0.00"; 
                    currentDensityThreshold = 0.0; 
 
                    processData(); 
                } catch (err) { 
                    statusEl.textContent = `Error: ${err.message}`; 
                    allElementData = []; 
                } 
            }; 
 
            reader.readAsText(file); 
        } 
 
        /** 
         * Inspects the first data element to find renderable fields. 
         */ 
        function discoverAvailableFields() { 
            availableFields = []; 
            if (allElementData.length === 0) return; 
 
            const firstEl = allElementData[0]; 
            for (const key in firstEl) { 
                const value = firstEl[key]; 
                if (typeof value === 'number' && key !== 'element_id') { 
                    availableFields.push(key); 
                } 
                if (key === 'principal_stresses' && Array.isArray(value) && value.length >= 3) { 
                    availableFields.push('principal_stresses_P1'); 
                    availableFields.push('principal_stresses_P2'); 
                    availableFields.push('principal_stresses_P3'); 
                } 
            } 
 
            if (availableFields.includes('von_mises_stress')) { 
                currentDataField = 'von_mises_stress'; 
            } else if (availableFields.length > 0) { 
                currentDataField = availableFields[0]; 
            } 
        } 
 
        /** 
         * Populates the dropdown <select> element. 
         */ 
        function populateDropdown() { 
            dataFieldSelect.innerHTML = ""; 
            availableFields.forEach(field => { 
                const option = document.createElement('option'); 
                option.value = field; 
                option.text = field; 
                dataFieldSelect.appendChild(option); 
            }); 
            dataFieldSelect.value = currentDataField; 
        } 
 
        /** 
         * Gets the value for a specific field from an element. 
         */ 
        function getElementValue(element, field) { 
            if (field === 'principal_stresses_P1') { 
                return element.principal_stresses ? element.principal_stresses[0] : 0; 
            } 
            if (field === 'principal_stresses_P2') { 
                return element.principal_stresses ? element.principal_stresses[1] : 0; 
            } 
            if (field === 'principal_stresses_P3') { 
                return element.principal_stresses ? element.principal_stresses[2] : 0; 
            } 
            return element[field] || 0; 
        } 
 
        /** 
         * Calculates min/max for the given field and updates the UI. 
         */ 
        function updateDataStats(field) { 
            if (allElementData.length === 0) return; 
 
            let min = Infinity; 
            let max = -Infinity; 
            allElementData.forEach(el => { 
                // --- MODIFIED: Only use visible elements for stats --- 
                const youngModulus = el.young_modulus || 0; 
                if (youngModulus >= currentDensityThreshold) { 
                    const value = getElementValue(el, field); 
                    if (value < min) min = value; 
                    if (value > max) max = value; 
                } 
            }); 
 
            // Handle case where no elements are visible 
            if (min === Infinity) { 
                min = 0; 
                max = 1; 
            } 
 
            dataMinStress = min; 
            dataMaxStress = max; 
            currentMin = dataMinStress; 
            currentMax = dataMaxStress; 
 
            if (currentMin === currentMax) { 
                currentMin -= 0.1 * Math.abs(currentMin) + 0.1; 
                currentMax += 0.1 * Math.abs(currentMax) + 0.1; 
            } 
 
            minInput.value = currentMin.toExponential(4); 
            maxInput.value = currentMax.toExponential(4); 
        } 
         
        /** 
         * Infers element size from centroid data. 
         */ 
        function calculateElementSize(elements) { 
            if (elements.length < 2) { 
                return { dx: 0.1, dy: 0.1, dz: 0.1 }; 
            } 
 
            const xCoords = [...new Set(elements.map(el => el.centroid[0]))].sort((a, b) => a - b); 
            const yCoords = [...new Set(elements.map(el => el.centroid[1]))].sort((a, b) => a - b); 
            const zCoords = [...new Set(elements.map(el => el.centroid[2]))].sort((a, b) => a - b); 
 
            const findMinGap = (coords) => { 
                if (coords.length < 2) return Infinity; 
                let minGap = Infinity; 
                for (let i = 1; i < coords.length; i++) { 
                    const gap = coords[i] - coords[i-1]; 
                    if (gap > 1e-6) { 
                        minGap = Math.min(minGap, gap); 
                    } 
                } 
                return minGap; 
            }; 
 
            let dx = findMinGap(xCoords); 
            let dy = findMinGap(yCoords); 
            let dz = findMinGap(zCoords); 
 
            const validSizes = [dx, dy, dz].filter(s => s !== Infinity && s > 1e-6); 
            const defaultSize = (validSizes.length > 0) ? validSizes[0] : 0.1; 
 
            if (dx === Infinity || dx <= 1e-6) dx = defaultSize; 
            if (dy === Infinity || dy <= 1e-6) dy = defaultSize; 
            if (dz === Infinity || dz <= 1e-6) dz = defaultSize; 
             
            console.log(`Inferred element size (dx, dy, dz): ${dx.toFixed(3)}, ${dy.toFixed(3)}, ${dz.toFixed(3)}`); 
            return { dx, dy, dz }; 
        } 
 
        /** 
         * Finds min/max stress and updates UI and scene. 
         */ 
        function processData() { 
            if (allElementData.length === 0) return; 
 
            elementSize = calculateElementSize(allElementData); 
            updateDataStats(currentDataField); 
            drawElements(); 
             
            if (rootNode && rootNode.getChildMeshes().length > 0) { 
                let minVec = new BABYLON.Vector3(Infinity, Infinity, Infinity); 
                let maxVec = new BABYLON.Vector3(-Infinity, -Infinity, -Infinity); 
 
                allElementData.forEach(el => { 
                    const pos = new BABYLON.Vector3(el.centroid[0], el.centroid[1], el.centroid[2]); 
                    minVec.MinimizeInPlace(pos); 
                    maxVec.MaximizeInPlace(pos); 
                }); 
                 
                const halfSize = new BABYLON.Vector3(elementSize.dx / 2, elementSize.dy / 2, elementSize.dz / 2); 
                minVec.subtractInPlace(halfSize); 
                maxVec.addInPlace(halfSize); 
 
                const boundingInfo = new BABYLON.BoundingInfo(minVec, maxVec); 
                scene.activeCamera.target = boundingInfo.center; 
                const maxDim = Math.max(boundingInfo.extent.x, boundingInfo.extent.y, boundingInfo.extent.z); 
                scene.activeCamera.radius = maxDim * 3;  
 
                if (ground) { 
                    const groundWidth = boundingInfo.extent.x * 2.5 + elementSize.dx * 4; 
                    const groundDepth = boundingInfo.extent.z * 2.5 + elementSize.dz * 4; 
                    const groundSize = Math.max(groundWidth, groundDepth, 10); 
                     
                    ground.scaling.x = groundSize / 100; 
                    ground.scaling.z = groundSize / 100; 
                    ground.position.y = boundingInfo.minimum.y - 0.01; 
                } 
            } 
        } 
 
        /** 
         * Creates all element instances. 
         */ 
        function drawElements() { 
            if (!scene) return; 
 
            if (rootNode) rootNode.dispose(); 
            if (templateBox) templateBox.dispose(); 
 
            rootNode = new BABYLON.TransformNode("elementRoot", scene); 
             
            templateBox = BABYLON.MeshBuilder.CreateBox("template", {  
                width: elementSize.dx,  
                height: elementSize.dy,  
                depth: elementSize.dz  
            }, scene); 
             
            templateBox.isVisible = false;  
            templateBox.registerInstancedBuffer("color", 3); 
             
            const templateMat = new BABYLON.StandardMaterial("templateMat", scene); 
            templateMat.diffuseColor = new BABYLON.Color3(1, 1, 1);  
            templateMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2); 
            templateBox.material = templateMat; 
 
            allElementData.forEach((el, index) => { 
                const centroid = el.centroid; 
                const boxInstance = templateBox.createInstance(`element_${index}`); 
                 
                boxInstance.position = new BABYLON.Vector3(centroid[0], centroid[1], centroid[2]); 
                boxInstance.parent = rootNode; 
                boxInstance.metadata = el; 
            }); 
             
            const count = updateElementVisuals(); // Apply initial visuals 
            statusEl.textContent = `Rendered ${allElementData.length} elements. Showing ${count}.`; 
        } 
 
        /** 
         * Updates visibility AND colors of all existing instances. 
         * Returns the count of visible elements. 
         */ 
        function updateElementVisuals() { 
            if (!rootNode) return 0; 
 
            const instances = rootNode.getChildMeshes(); 
            if (instances.length === 0) return 0; 
 
            let visibleCount = 0; 
            instances.forEach(instance => { 
                if (instance.metadata && instance.instancedBuffers) { 
                     
                    // --- 1. VISIBILITY CHECK --- 
                    // We assume young_modulus is the 0-1 density field 
                    const youngModulus = instance.metadata.young_modulus || 0;  
                    const isVisible = (youngModulus >= currentDensityThreshold); 
                    instance.isVisible = isVisible; 
 
                    if (isVisible) { 
                        // --- 2. COLOR LOGIC --- 
                        const value = getElementValue(instance.metadata, currentDataField); 
                        instance.instancedBuffers.color = getColorForValue(value); 
                        visibleCount++; 
                    } 
                } else { 
                    instance.isVisible = false; 
                } 
            }); 
             
            return visibleCount; // Return the count 
        } 
 
        /** 
         * Converts a value to a rainbow color. 
         */ 
        function getColorForValue(value) { 
            let range = currentMax - currentMin; 
            if (range <= 0) range = 1; 
 
            let normalized = (value - currentMin) / range; 
            normalized = Math.max(0, Math.min(1, normalized)); // Clamp 0-1 
 
            const hue = (1.0 - normalized) * 240; // 240=Blue, 0=Red 
            return BABYLON.Color3.FromHSV(hue, 1, 1); 
        } 
 
        /** 
         * Applies the user-defined min/max limits for COLOR. 
         */ 
        function handleApplyLimits() { 
            const minVal = parseFloat(minInput.value); 
            const maxVal = parseFloat(maxInput.value); 
 
            if (isNaN(minVal) || isNaN(maxVal)) { 
                statusEl.textContent = "Error: Invalid min/max values."; 
                return; 
            } 
            if (minVal >= maxVal) { 
                statusEl.textContent = "Error: Min must be less than max."; 
                return; 
            } 
 
            currentMin = minVal; 
            currentMax = maxVal; 
             
            // Re-apply visuals (colors will change) 
            const count = updateElementVisuals(); 
            statusEl.textContent = `Color limits applied. Showing ${count} elements.`; 
        } 
 
        /** 
         * Handles the user changing the data field dropdown for COLOR. 
         */ 
        function handleFieldChange(event) { 
            currentDataField = event.target.value; 
             
            // Recalculate stats for the new field (based on visible elements) 
            updateDataStats(currentDataField); 
 
            // Update all instance visuals (colors will change) 
            const count = updateElementVisuals(); 
            statusEl.textContent = `Switched to ${currentDataField}. Showing ${count} elements.`; 
        } 
 
        /** 
         * (NEW) Handles the user sliding the density/visibility bar. 
         */ 
        function handleDensityChange(event) { 
            currentDensityThreshold = parseFloat(event.target.value); 
            densityValue.textContent = currentDensityThreshold.toFixed(2); 
             
            // Re-calculate color stats based on new set of visible elements 
            updateDataStats(currentDataField);  
 
            // Update all instance visuals (visibility and colors will change) 
            const visibleCount = updateElementVisuals(); 
 
            statusEl.textContent = `Threshold: ${currentDensityThreshold.toFixed(2)}. Showing ${visibleCount} elements.`; 
        } 
 
        // --- Event Listeners --- 
        window.addEventListener('DOMContentLoaded', initBabylon); 
        fileInput.addEventListener('change', handleFileLoad); 
        applyButton.addEventListener('click', handleApplyLimits); 
        dataFieldSelect.addEventListener('change', handleFieldChange); 
        densitySlider.addEventListener('input', handleDensityChange); // --- NEW LISTENER --- 
 
    </script> 
</body> 
</html> 
"// # FILE: .\PREPOST\pre_yaml.html";
<!DOCTYPE html> 
<html> 
<head> 
    <meta charset="utf-8" /> 
    <title>FEM Visualization</title> 
    <style> 
        /* Tailwind-inspired aesthetics for better looks */ 
        html, body { 
            width: 100%; height: 100%; 
            margin: 0; overflow: hidden; 
            font-family: 'Inter', sans-serif; 
            background-color: #f7f7f7; 
        } 
        #renderCanvas { 
            width: 100%; height: 100%; 
            touch-action: none; 
        } 
        #controls { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            z-index: 10; 
            background: rgba(255,255,255,0.95); 
            padding: 15px; 
            border-radius: 8px; 
            max-width: 320px; 
            max-height: 95vh; 
            overflow-y: auto; 
            box-shadow: 0 8px 16px rgba(0,0,0,0.2); /* Stronger shadow */ 
            border: 1px solid #e0e0e0; 
        } 
        .legend { 
            display: flex; 
            align-items: center; 
            margin-bottom: 5px; 
            font-size: 14px; 
            color: #4b5563; 
        } 
        .color-box { 
            width: 15px; 
            height: 15px; 
            margin-right: 8px; 
            display: inline-block; 
            border-radius: 3px; 
            border: 1px solid rgba(0,0,0,0.1); 
        } 
         
        #controls label { 
            display: block; 
            margin-top: 10px; 
            font-size: 14px; 
            font-weight: 600; /* Semi-bold */ 
            color: #1f2937; 
        } 
        .config-input { 
            width: 100%; 
            padding: 8px; 
            box-sizing: border-box; 
            border: 1px solid #d1d5db; 
            border-radius: 4px; 
            margin-top: 4px; 
            font-size: 14px; 
            transition: border-color 0.15s; 
        } 
        .config-input:focus { 
            border-color: #3b82f6; 
            outline: none; 
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2); 
        } 
 
        #fileInput { 
            margin-top: 15px; 
            width: 100%; 
        } 
        .btn { 
            display: block; 
            width: 100%; 
            padding: 10px; 
            margin-top: 10px; 
            background-color: #3b82f6; /* Tailwind Blue-500 */ 
            color: white; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer; 
            font-size: 15px; 
            font-weight: 700; 
            transition: background-color 0.2s; 
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); 
        } 
        .btn:hover:not(:disabled) { 
            background-color: #2563eb; /* Tailwind Blue-600 */ 
        } 
        .btn:disabled { 
            background-color: #9ca3af; 
            cursor: not-allowed; 
            box-shadow: none; 
        } 
        #instructions { 
            margin-top: 10px; 
            font-size: 14px; 
            color: #6b7280; 
            padding: 8px; 
            border-left: 4px solid #3b82f6; 
            background-color: #eff6ff; 
            border-radius: 4px; 
        } 
        #objectInfo { 
            margin-top: 10px; 
            padding: 10px; 
            background-color: #f3f4f6; 
            border-radius: 4px; 
            font-size: 12px; 
            white-space: pre-line; 
            border: 1px solid #e5e7eb; 
        } 
        hr { 
            margin: 15px 0; 
            border: 0; 
            border-top: 1px solid #e5e7eb; 
        } 
    </style> 
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet"> 
</head> 
<body> 
<div id="controls"> 
    <h3>
 ⚙
 FEM Optimization Configurator</h3> 
    <h4>Legend</h4> 
    <div class="legend"> 
        <div class="color-box" style="background-color: blue; opacity: 0.5;"></div> 
        <span>Add Geometry (Blue)</span> 
    </div> 
    <div class="legend"> 
        <div class="color-box" style="background-color: red; opacity: 0.5;"></div> 
        <span>Remove Geometry (Red)</span> 
    </div> 
    <div class="legend"> 
        <div class="color-box" style="background-color: green; opacity: 0.5;"></div> 
        <span>Boundary Conditions (Green)</span> 
    </div> 
    <div class="legend"> 
        <div class="color-box" style="background-color: white; border: 1px solid #333;"></div> 
        <span>External Forces (White)</span> 
    </div> 
 
    <hr/> 
 
    <label for="iterationsInput">Number of Optimization Iterations:</label> 
    <input type="number" id="iterationsInput" class="config-input" value="0" min="0" step="1"> 
     
    <label for="stressInput">L1 Stress Allowable Target:</label> 
    <input type="number" id="stressInput" class="config-input" value="1.0" step="0.01"> 
     
    <hr/> 
 
    <input type="file" id="fileInput" accept=".yaml, .yml" /> 
    <div id="instructions">Please load an existing FEM config file (.yaml or .yml) to begin.</div> 
     
    <div id="objectInfo">No object selected</div> 
     
    <button id="downloadBtn" class="btn" disabled>Download Modified Config (.yaml)</button> 
</div> 
 
<canvas id="renderCanvas"></canvas> 
 
<script src="https://cdnjs.cloudflare.com/ajax/libs/babylonjs/6.16.0/babylon.js"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/babylonjs-gui/6.16.0/babylonjs.gui.min.js"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script> 
<script> 
    // Constants and Configuration for Comment Injection 
    const YAML_COMMENTS = { 
        // Top-level description 
        HEADER: "# Configuration file for HEXA FEM Topology Optimization, controlling geometry, material, optimization goals, and solver hyperparameters.", 
         
        // geometry 
        "geometry:": [ 
            "  # Domain dimension in the X direction (meters).", 
            "  # Domain dimension in the Y direction (meters).", 
            "  # Domain dimension in the Z direction (meters).", 
            "  # Target total number of elements. The mesh generator calculates N_x, N_y, N_z based on dimension ratios.", 
            "  # Shapes define fixed regions (void or solid) that are excluded from optimization." 
        ], 
        // geometry.sphereX or geometry.boxX 
        "type": "    # Geometric type: 'sphere' or 'box'.", 
        "center": "    # [X, Y, Z] coordinate of the shape center.", 
        "diameter": "    # Diameter of the sphere.", 
        "side": "    # Side length of the cube/box.", 
        "action": "    # Fixed density type: 'remove' (min_density) or 'add' (max_density_initial_add).", 
 
        // boundary_conditions 
        "boundary_conditions:": [ 
            "# Defines fixed displacement constraints on nodes matching the location criteria." 
        ], 
        "location_bc": "    # Constraint location. Format: [X, Y, Z] using absolute coordinate, 0-1 fraction, or ':' (all).", 
        "DoFs": "    # Constrained Degrees of Freedom: 1=X translation, 2=Y translation, 3=Z translation.", 
 
        // external_forces 
        "external_forces:": [ 
            "# Defines concentrated forces applied to nodes matching the location criteria." 
        ], 
        "location_force": "    # Location for force application.", 
        "F": "    # Force vector [Fx, Fy, Fz] (applied as total force, distributed if using 'location').", 
 
        // material 
        "material:": [ 
            "# Base material properties for solid elements." 
        ], 
        "E": "  # Young's Modulus (base value).", 
        "nu": "  # Poisson's Ratio.", 
 
        // root scalar parameters 
        "number_of_iterations:": "# Number of optimization iterations. Set to 0 for a single FEM analysis run.", 
        "l1_stress_allowable:": "# Target maximum allowable L1 stress norm (constraint value).", 
 
        // optimization_parameters 
        "optimization_parameters:": [ 
            "# Parameters related to the SIMP and density update rule." 
        ], 
        "min_density": "  # Minimum allowable element density (rho_min). Higher values increase stability but introduce 'gray' elements. Recommended: 0.001 to 0.01.", 
        "max_density_initial_add": "  # Initial density for 'add' shapes (controls initial fixed stiffness). Typically >= 1.0.", 
        "density_clamp_max": "  # Maximum value for element density. Usually 1.0.", 
 
        // solver_parameters 
        "solver_parameters:": [ 
            "# Parameters for selecting the solver type, tolerance, and numerical stability tuning." 
        ], 
        "solver_type": "  # Solver type: 'direct' (small problems), 'matrix_free' (CPU iterative), or 'gpu' (GPU iterative).", 
        "tolerance": "  # CG/Krylov solver convergence tolerance (Relative Residual Norm). Recommended 1e-6 or lower.", 
        "max_iterations": "  # Maximum number of iterations allowed for the chosen iterative solver (CG/Krylov).", 
        "diagonal_shift_factor": "  # Regularization factor (delta) applied as a fraction of max diagonal element. Critical for ill-conditioned matrices. Recommended 1e-6 to 1e-4.", 
        "gpu_method": "  # If solver_type is 'gpu': 'native' (CUDA CG) or 'krylov' (Krylov.jl wrapper).", 
        "krylov_solver": "  # If gpu_method is 'krylov': Specify algorithm: 'cg', 'minres', or 'bicgstab'." 
    }; 
 
    // Global references for DOM elements 
    const objectInfoDiv = document.getElementById("objectInfo"); 
    const downloadBtn = document.getElementById("downloadBtn"); 
    const iterationsInput = document.getElementById('iterationsInput'); 
    const stressInput = document.getElementById('stressInput'); 
 
    // Basic setup 
    var canvas = document.getElementById("renderCanvas"); 
    var engine = new BABYLON.Engine(canvas, true); 
    var scene = new BABYLON.Scene(engine); 
 
    // Camera and Lights setup (Unchanged) 
    var camera = new BABYLON.ArcRotateCamera("Camera",  
        -Math.PI/2, Math.PI/2.5,  
        50,  
        BABYLON.Vector3.Zero(),  
        scene 
    ); 
    camera.attachControl(canvas, true); 
    camera.lowerBetaLimit = 0.01; 
    camera.upperBetaLimit = Math.PI - 0.01; 
 
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene); 
    light.intensity = 0.7; 
    var dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene); 
    dirLight.intensity = 0.5; 
 
    // Create gizmo manager 
    var gizmoManager = new BABYLON.GizmoManager(scene); 
    gizmoManager.positionGizmoEnabled = true; 
    gizmoManager.attachableMeshes = []; 
    gizmoManager.usePointerToAttachGizmos = false; 
 
    // Store references to permanent scene objects 
    var permanentObjects = ["Camera", "light", "dirLight"]; 
    var axesObjects = [];  
 
    // Global config variables 
    var meshToConfigMap = new Map(); 
    var currentConfig = null; 
 
    // [BEGIN] Z-AXIS UTILITIES (Unchanged from previous revision for consistency) 
 
    function clearScene() { 
        scene.meshes.slice().forEach(m => { 
            if (!permanentObjects.includes(m.name)) { 
                m.dispose(); 
            } 
        }); 
        gizmoManager.attachableMeshes = []; 
        gizmoManager.attachToMesh(null); 
        meshToConfigMap.clear(); 
        axesObjects.forEach(obj => { if (obj) obj.dispose(); }); 
        axesObjects = []; 
        objectInfoDiv.textContent = "No object selected"; 
        iterationsInput.value = 0; 
        stressInput.value = 1.0; 
        downloadBtn.disabled = true; 
    } 
 
    function createCoordinateAxes(size = 10) { 
        axesObjects.forEach(obj => { if (obj) obj.dispose(); }); 
        axesObjects = []; 
        function makeAxis(name, start, end, color) { 
            var axis = BABYLON.MeshBuilder.CreateLines(name, {points: [start, end], updatable: true}, scene); 
            axis.color = color; 
            axis.isPickable = false; 
            return axis; 
        } 
 
        var xAxis = makeAxis("xAxis", BABYLON.Vector3.Zero(), new BABYLON.Vector3(size, 0, 0), new BABYLON.Color3(1, 0, 0)); 
        var yAxis = makeAxis("yAxis", BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, size, 0), new BABYLON.Color3(0, 1, 0)); 
        var zAxis = makeAxis("zAxis", BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, 0, size), new BABYLON.Color3(0, 0, 1));  
        axesObjects.push(xAxis, yAxis, zAxis); 
         
        function createAxisLabel(txt, pos, color) { 
            var dt = new BABYLON.DynamicTexture("AxisLabel"+txt, {width:64, height:64}, scene); 
            dt.hasAlpha = true; 
            dt.drawText(txt, null, 48, "bold 48px Arial", color.toHexString(), "transparent"); 
            var plane = BABYLON.MeshBuilder.CreatePlane("Label_"+txt, {width:1, height:1}, scene); 
            plane.position = pos; 
            plane.isPickable = false; 
            var mat = new BABYLON.StandardMaterial("Mat_"+txt, scene); 
            mat.diffuseTexture = dt; 
            mat.opacityTexture = dt; 
            mat.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND; 
            mat.backFaceCulling = false; 
            mat.emissiveColor = color; 
            plane.material = mat; 
            plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL; 
            axesObjects.push(plane); 
            return plane; 
        } 
         
        createAxisLabel("X", new BABYLON.Vector3(size + 1, 0, 0), new BABYLON.Color3(1, 0, 0)); 
        createAxisLabel("Y", new BABYLON.Vector3(0, size + 1, 0), new BABYLON.Color3(0, 1, 0)); 
        createAxisLabel("Z", new BABYLON.Vector3(0, 0, -size - 1), new BABYLON.Color3(0, 0, 1));  
    } 
 
    function interpretLocationComponent(spec, cmin, cmax) { 
        if (spec === ":") return null;  
        if (typeof spec === "number") { 
            if (spec >= 0 && spec <= 1) { 
                return cmin + spec*(cmax - cmin); 
            } else { 
                return spec; 
            } 
        } 
        if (typeof spec === "string" && spec.trim().endsWith("%")) { 
            var frac = parseFloat(spec.replace("%",""))/100; 
            frac = Math.min(Math.max(frac,0),1); 
            return cmin + frac*(cmax - cmin); 
        } 
        throw new Error("Invalid location component: " + spec); 
    } 
     
    function createArrow(name, tip, direction, length, color) { 
        var tail = tip.subtract(direction.scale(length)); 
        var shaftHeight = length * 0.8; 
        var coneHeight  = length * 0.2; 
        var shaft = BABYLON.MeshBuilder.CreateCylinder(name+"_shaft", {height: shaftHeight, diameter: 0.3}, scene); 
        shaft.position = tail.add(direction.scale(shaftHeight/2)); 
        var cone = BABYLON.MeshBuilder.CreateCylinder(name+"_cone", {height: coneHeight, diameterTop: 0, diameterBottom: 0.6}, scene); 
        cone.position = tip.subtract(direction.scale(coneHeight/2)); 
 
        var defaultDir = new BABYLON.Vector3(0,1,0); 
        var angle = Math.acos(BABYLON.Vector3.Dot(defaultDir, direction)); 
        if (angle > 1e-6) { 
            var axis = BABYLON.Vector3.Cross(defaultDir, direction).normalize(); 
            var quat = BABYLON.Quaternion.RotationAxis(axis, angle); 
            shaft.rotationQuaternion = quat; 
            cone.rotationQuaternion = quat; 
        } 
 
        var mat = new BABYLON.StandardMaterial(name+"_mat", scene); 
        mat.diffuseColor = color || new BABYLON.Color3(1,1,1); 
        var arrow = BABYLON.Mesh.MergeMeshes([shaft, cone], true, false, null, false, true, scene); 
        arrow.material = mat; 
        arrow.isPickable = false;  
        return arrow; 
    } 
 
    function createDomainBlock(dims) { 
        var corners = [ 
            [dims.xMin, dims.yMin, dims.zMin], [dims.xMax, dims.yMin, dims.zMin], 
            [dims.xMax, dims.yMin, dims.zMin], [dims.xMax, dims.yMax, dims.zMin], 
            [dims.xMax, dims.yMax, dims.zMin], [dims.xMin, dims.yMax, dims.zMin], 
            [dims.xMin, dims.yMax, dims.zMin], [dims.xMin, dims.yMin, dims.zMin], 
            [dims.xMin, dims.yMin, dims.zMax], [dims.xMax, dims.yMin, dims.zMax], 
            [dims.xMax, dims.yMin, dims.zMax], [dims.xMax, dims.yMax, dims.zMax], 
            [dims.xMax, dims.yMax, dims.zMax], [dims.xMin, dims.yMax, dims.zMax], 
            [dims.xMin, dims.yMax, dims.zMax], [dims.xMin, dims.yMin, dims.zMax], 
            [dims.xMin, dims.yMin, dims.zMin], [dims.xMin, dims.yMin, dims.zMax], 
            [dims.xMax, dims.yMin, dims.zMin], [dims.xMax, dims.yMin, dims.zMax], 
            [dims.xMin, dims.yMax, dims.zMin], [dims.xMin, dims.yMax, dims.zMax], 
            [dims.xMax, dims.yMax, dims.zMin], [dims.xMax, dims.yMax, dims.zMax] 
        ]; 
        for (var i=0; i<corners.length; i+=2) { 
            let pts = [ 
                new BABYLON.Vector3(corners[i][0], corners[i][1], corners[i][2]), 
                new BABYLON.Vector3(corners[i+1][0], corners[i+1][1], corners[i+1][2]) 
            ]; 
            var lines = BABYLON.MeshBuilder.CreateLines("domainLine"+i, {points: pts}, scene); 
            lines.color = new BABYLON.Color3(0.5, 0.5, 0.5); 
            lines.isPickable = false; 
        } 
 
        var w = dims.xMax - dims.xMin, h = dims.yMax - dims.yMin, d = dims.zMax - dims.zMin; 
        var domainBlock = BABYLON.MeshBuilder.CreateBox("domainBlock", {width: w, height: h, depth: d}, scene); 
        domainBlock.position = new BABYLON.Vector3((dims.xMax + dims.xMin)/2, (dims.yMax + dims.yMin)/2, (dims.zMax + dims.zMin)/2); 
        domainBlock.isPickable = false; 
 
        var mat = new BABYLON.StandardMaterial("domainMat", scene); 
        mat.diffuseColor = new BABYLON.Color3(1,1,0); 
        mat.alpha = 0.3; 
        mat.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND; 
        domainBlock.material = mat; 
    } 
 
    function createBCArrows(bc, dims, idx) { 
        var loc = bc.location; 
        var dofs = bc.DoFs || []; 
        var dofColorMap = { 
            1: new BABYLON.Color3(1,0,0), 2: new BABYLON.Color3(0,1,0), 3: new BABYLON.Color3(0,0,1) 
        }; 
        var dofDirectionMap = { 
            1: new BABYLON.Vector3(1,0,0), 2: new BABYLON.Vector3(0,1,0), 3: new BABYLON.Vector3(0,0,-1) 
        }; 
 
        var avgDim = (dims.xMax-dims.xMin + dims.yMax-dims.yMin + dims.zMax-dims.zMin) / 3; 
        var step = Math.max(1, avgDim / 5); 
 
        function coordArray(spec, cMin, cMax) { 
            if (spec === ":") { 
                let arr = []; 
                let cur = cMin; 
                while (cur <= cMax + 1e-9) {  
                    arr.push(cur); 
                    cur += step; 
                } 
                if (Math.abs(arr[arr.length - 1] - cMax) > 1e-9) { 
                    arr.push(cMax); 
                } 
                return Array.from(new Set(arr)); 
            } else { 
                let val = interpretLocationComponent(spec, cMin, cMax); 
                return [val]; 
            } 
        } 
 
        var xArr = coordArray(loc[0], dims.xMin, dims.xMax); 
        var yArr = coordArray(loc[1], dims.yMin, dims.yMax); 
        var zFemArr = coordArray(loc[2], dims.zMin, dims.zMax); 
 
        var bcMarkerColor = new BABYLON.Color3(0,1,0); 
 
        xArr.forEach(x => { 
            yArr.forEach(y => { 
                zFemArr.forEach(z_fem => { 
                    var z_b = -z_fem;  
                    var position = new BABYLON.Vector3(x,y,z_b); 
 
                    var marker = BABYLON.MeshBuilder.CreateSphere("BCmarker_" + idx + "_" + x + y + z_fem, {diameter:0.3}, scene); 
                    marker.position.copyFrom(position); 
                    marker.isPickable = false; 
                    var mMat = new BABYLON.StandardMaterial("BCmarkerMat_" + idx, scene); 
                    mMat.diffuseColor = bcMarkerColor; 
                    mMat.alpha = 0.5; 
                    mMat.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND; 
                    marker.material = mMat; 
 
                    dofs.forEach(dof => { 
                        if (dofDirectionMap[dof]) { 
                            createArrow(`BCarrow_dof${dof}_${idx}_${x}${y}${z_fem}`, position, dofDirectionMap[dof], 0.8, dofColorMap[dof]); 
                        } 
                    }); 
                }); 
            }); 
        }); 
 
        var dofText = "BC: DoFs " + dofs.join(", "); 
        var dt = new BABYLON.DynamicTexture("bcText_" + idx, {width:256, height:64}, scene); 
        dt.hasAlpha = true; 
        dt.drawText(dofText, null, 40, "bold 24px Arial", "white", "transparent"); 
 
        var textPlane = BABYLON.MeshBuilder.CreatePlane("bcTextPlane_" + idx, {width:5, height:1.5}, scene); 
        textPlane.isPickable = false; 
        var textMat = new BABYLON.StandardMaterial("bcTextMat_" + idx, scene); 
        textMat.diffuseTexture = dt; 
        textMat.opacityTexture = dt; 
        textMat.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND; 
        textMat.emissiveColor = bcMarkerColor; 
        textPlane.material = textMat; 
 
        var midX = (xArr[0] + xArr[xArr.length-1])/2; 
        var midY = (yArr[0] + yArr[yArr.length-1])/2; 
        var midZ_fem = (zFemArr[0] + zFemArr[zFemArr.length-1])/2; 
        textPlane.position.set(midX, midY + 1, -midZ_fem);  
        textPlane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL; 
    } 
 
    function buildScene(config) { 
        clearScene(); 
        currentConfig = JSON.parse(JSON.stringify(config)); 
 
        iterationsInput.value = currentConfig.number_of_iterations || 0; 
        stressInput.value = currentConfig.l1_stress_allowable || 1.0; 
        downloadBtn.disabled = false; 
 
        createCoordinateAxes(5); 
 
        var geom = config.geometry; 
        var dims = { 
            xMin: 0, xMax: geom.length_x || 10, 
            yMin: 0, yMax: geom.length_y || 10, 
            zMin: 0, zMax: geom.length_z || 10 
        }; 
 
        var babylonDims = { 
            xMin: dims.xMin, xMax: dims.xMax, 
            yMin: dims.yMin, yMax: dims.yMax, 
            zMin: -dims.zMax, zMax: -dims.zMin  
        }; 
        createDomainBlock(babylonDims); 
 
        var minX = babylonDims.xMin, maxX = babylonDims.xMax; 
        var minY = babylonDims.yMin, maxY = babylonDims.yMax; 
        var minZ = babylonDims.zMin, maxZ = babylonDims.zMax; 
 
        function expandBounds(x, y, z, halfSize=0) { 
            if (x - halfSize < minX) minX = x - halfSize; 
            if (x + halfSize > maxX) maxX = x + halfSize; 
            if (y - halfSize < minY) minY = y - halfSize; 
            if (y + halfSize > maxY) maxY = y + halfSize; 
            if (z - halfSize < minZ) minZ = z - halfSize; 
            if (z + halfSize > maxZ) maxZ = z + halfSize; 
        } 
 
        // Spheres and Boxes 
        Object.keys(geom).filter(k=>k.startsWith("sphere") || k.startsWith("box")).forEach(key => { 
            var g = geom[key]; 
            var type = g.type; 
            var mesh; 
            var halfSize; 
 
            if (type === "sphere") { 
                mesh = BABYLON.MeshBuilder.CreateSphere(key, {diameter: g.diameter}, scene); 
                halfSize = g.diameter/2; 
            } else if (type === "box") { 
                mesh = BABYLON.MeshBuilder.CreateBox(key, {width: g.side, height: g.side, depth: g.side}, scene); 
                halfSize = g.side/2; 
            } else { 
                return; // Skip unknown types 
            } 
 
            mesh.position.set(g.center[0], g.center[1], -g.center[2]);  
 
            var mat = new BABYLON.StandardMaterial(key+"_mat", scene); 
            mat.diffuseColor = (g.action === "add") ? new BABYLON.Color3(0,0,1) : new BABYLON.Color3(1,0,0); 
            mat.alpha = 0.5; 
            mat.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND; 
            mesh.material = mat; 
             
            gizmoManager.attachableMeshes.push(mesh); 
             
            meshToConfigMap.set(key, { type: type, configKey: key }); 
            expandBounds(mesh.position.x, mesh.position.y, mesh.position.z, halfSize);  
        }); 
 
        // Boundary conditions 
        if (config.boundary_conditions) { 
            config.boundary_conditions.forEach((bc, i) => { 
                createBCArrows(bc, dims, i); 
            }); 
        } 
 
        // External Forces 
        if (config.external_forces) { 
            config.external_forces.forEach((force, i) => { 
                var loc = force.location; 
                if (!loc || loc.length<3) return; 
                var x = interpretLocationComponent(loc[0], dims.xMin, dims.xMax); 
                var y = interpretLocationComponent(loc[1], dims.yMin, dims.yMax); 
                var z_fem = interpretLocationComponent(loc[2], dims.zMin, dims.zMax); 
                var point = new BABYLON.Vector3(x, y, -z_fem); 
 
                var F = force.F.slice();  
                while (F.length<3) F.push(0); 
                var vec = new BABYLON.Vector3(F[0], F[1], -F[2]);  
 
                var len = vec.length(); 
                if (len > 1e-9) { 
                    var dir = vec.normalize(); 
                    var arrowLen = Math.min(len, 5) * 0.8;  
                    var arrow = createArrow("forceArrow"+i, point, dir, arrowLen, new BABYLON.Color3(1,1,1)); 
                    arrow.isPickable = false; 
 
                    var labelTxt = `Force: [${F[0].toFixed(1)}, ${F[1].toFixed(1)}, ${F[2].toFixed(1)}]`; 
                    var dt = new BABYLON.DynamicTexture("forceDT"+i, {width:256, height:64}, scene); 
                    dt.hasAlpha = true; 
                    dt.drawText(labelTxt, null, 40, "bold 20px Arial", "white", "transparent"); 
 
                    var pl = BABYLON.MeshBuilder.CreatePlane("forcePlane"+i, {width:6, height:1.5}, scene); 
                    pl.isPickable = false; 
                    var pm = new BABYLON.StandardMaterial("forceTextMat"+i, scene); 
                    pm.diffuseTexture = dt; 
                    pm.opacityTexture = dt; 
                    pm.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND; 
                    pm.emissiveColor = new BABYLON.Color3(1,1,1); 
                    pm.backFaceCulling = false; 
                    pl.material = pm; 
                    pl.position = point.subtract(dir.scale(2)).add(new BABYLON.Vector3(0,1.5,0)); 
                    pl.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL; 
 
                    expandBounds(point.x, point.y, point.z);  
                    expandBounds(point.x - dir.x * arrowLen, point.y - dir.y * arrowLen, point.z - dir.z * arrowLen); 
                } 
            }); 
        } 
 
        var maxDimension = Math.max(maxX-minX, maxY-minY, maxZ-minZ); 
        createCoordinateAxes(maxDimension * 0.25); 
 
        var centerX = 0.5*(minX + maxX); 
        var centerY = 0.5*(minY + maxY); 
        var centerZ = 0.5*(minZ + maxZ); 
        camera.target = new BABYLON.Vector3(centerX, centerY, centerZ);  
 
        var dx = maxX - minX; 
        var dy = maxY - minY; 
        var dz = maxZ - minZ; 
        var diag = Math.sqrt(dx*dx + dy*dy + dz*dz); 
        camera.radius = diag * 1.2; 
    } 
 
    function updateConfigFromScene() { 
        if (!currentConfig) return; 
 
        scene.meshes.forEach(mesh => { 
            const configInfo = meshToConfigMap.get(mesh.name); 
            if (configInfo) { 
                const { type, configKey } = configInfo; 
                 
                if (type === "sphere" || type === "box") { 
                    currentConfig.geometry[configKey].center = [ 
                        mesh.position.x, 
                        mesh.position.y, 
                        -mesh.position.z // Flip Z-axis back 
                    ]; 
                } 
            } 
        }); 
         
        const iterations = parseInt(iterationsInput.value, 10); 
        const stress = parseFloat(stressInput.value); 
 
        currentConfig.number_of_iterations = isNaN(iterations) ? 0 : iterations; 
        currentConfig.l1_stress_allowable = isNaN(stress) ? 1.0 : stress; 
         
        return currentConfig; 
    } 
    // [END] Z-AXIS UTILITIES 
 
    // [BEGIN] MODIFIED COMMENT INJECTION LOGIC 
 
    /** 
     * Finds and inserts comments into the generated YAML string. 
     * @param {string} yamlString The YAML string output from jsyaml.dump(). 
     * @param {object} config The original configuration object (used for iterating over dynamic keys). 
     * @returns {string} The YAML string with comments injected. 
     */ 
    function injectYamlComments(yamlString, config) { 
        let lines = yamlString.split('\n'); 
        let output = []; 
        let inGeometry = false; 
        let inArray = false; // Tracks if inside boundary_conditions or external_forces array 
        let indentLevel = 0; 
        let currentDynamicKey = null; 
 
        output.push(YAML_COMMENTS.HEADER); 
 
        for (let i = 0; i < lines.length; i++) { 
            let line = lines[i]; 
            let trimmed = line.trim(); 
            indentLevel = line.search(/\S/);  
 
            // 1. TOP LEVEL HEADINGS 
            if (indentLevel === 0 && trimmed.endsWith(':')) { 
                const key = trimmed; 
                inGeometry = key.startsWith("geometry"); 
                inArray = key.startsWith("boundary_conditions") || key.startsWith("external_forces"); 
 
                const comments = YAML_COMMENTS[key]; 
                if (comments) { 
                    output.push(''); 
                    if (Array.isArray(comments)) { 
                        comments.forEach(c => output.push(c)); 
                    } else { 
                        // For scalar root keys like number_of_iterations 
                        output.push(comments); 
                    } 
                } 
                output.push(line); 
                continue; 
            }  
             
            // 2. DYNAMIC GEOMETRY COMMENTS 
            if (inGeometry && indentLevel === 2 && trimmed.match(/^(sphere|box)\d+:$/)) { 
                // If we enter a new shape block, reset currentDynamicKey to handle sub-properties 
                currentDynamicKey = trimmed.slice(0, -1); 
                output.push(line); 
                continue; 
            } 
 
            if (currentDynamicKey && indentLevel === 4) { 
                const propKey = trimmed.split(':')[0].trim(); 
                const comment = YAML_COMMENTS[propKey]; 
                 
                if (comment) { 
                    output.push(comment); 
                } 
                output.push(line); 
                continue; 
            }  
 
            // 3. ARRAY ELEMENT COMMENTS (BC and Forces) 
            if (inArray && trimmed === '-') { 
                const arrayName = lines[i - 1].trim().split(':')[0]; 
                if (arrayName === 'boundary_conditions') { 
                    const comment = YAML_COMMENTS['boundary_conditions:'][0]; 
                    if (i > 0 && lines[i-1].trim() === 'boundary_conditions:') { 
                         // Comment for the whole block is already added, skip repetition 
                    } else { 
                        output.push(''); 
                        output.push(comment); 
                    } 
                     
                    // Push the array dash 
                    output.push(line); 
 
                    // Search for inner array properties 
                    for (let j = i + 1; j < lines.length; j++) { 
                        let innerLine = lines[j]; 
                        let innerTrimmed = innerLine.trim(); 
                        let innerIndent = innerLine.search(/\S/); 
                        if (innerIndent < indentLevel) break; // Exit block 
                        if (innerTrimmed.startsWith('location:')) { 
                            output.push(YAML_COMMENTS.location_bc); 
                            output.push(innerLine); 
                        } else if (innerTrimmed.startsWith('DoFs:')) { 
                            output.push(YAML_COMMENTS.DoFs); 
                            output.push(innerLine); 
                        } else { 
                            output.push(innerLine); 
                        } 
                        i = j; // Advance outer loop index 
                    } 
                    i--; // Correct the index after the inner loop increment 
                    continue; 
 
                } else if (arrayName === 'external_forces') { 
                    const comment = YAML_COMMENTS['external_forces:'][0]; 
                     if (i > 0 && lines[i-1].trim() === 'external_forces:') { 
                         // Comment for the whole block is already added, skip repetition 
                    } else { 
                        output.push(''); 
                        output.push(comment); 
                    } 
 
                    // Push the array dash 
                    output.push(line); 
 
                    // Search for inner array properties 
                    for (let j = i + 1; j < lines.length; j++) { 
                        let innerLine = lines[j]; 
                        let innerTrimmed = innerLine.trim(); 
                        let innerIndent = innerLine.search(/\S/); 
                        if (innerIndent < indentLevel) break; // Exit block 
                        if (innerTrimmed.startsWith('location:')) { 
                            output.push(YAML_COMMENTS.location_force); 
                            output.push(innerLine); 
                        } else if (innerTrimmed.startsWith('F:')) { 
                            output.push(YAML_COMMENTS.F); 
                            output.push(innerLine); 
                        } else { 
                            output.push(innerLine); 
                        } 
                        i = j; // Advance outer loop index 
                    } 
                    i--; // Correct the index after the inner loop increment 
                    continue; 
                } 
            } 
 
 
            // If none of the above, just push the line 
            output.push(line); 
        } 
 
        // Add specific geometry/material dimensions comments to the same line (post-processing) 
        let finalOutput = output.join('\n'); 
         
        // Geometry dimension comments (using a single comment from the array, since we injected the full block earlier) 
        finalOutput = finalOutput.replace( 
            /(  length_x: [\d.-]+)/,  
            `$1 ${YAML_COMMENTS["geometry:"][0].trim()}` 
        ); 
        finalOutput = finalOutput.replace( 
            /(  length_y: [\d.-]+)/,  
            `$1 ${YAML_COMMENTS["geometry:"][1].trim()}` 
        ); 
        finalOutput = finalOutput.replace( 
            /(  length_z: [\d.-]+)/,  
            `$1 ${YAML_COMMENTS["geometry:"][2].trim()}` 
        ); 
        finalOutput = finalOutput.replace( 
            /(  target_elem_count: [\d.-]+)/, 
            `$1 ${YAML_COMMENTS["geometry:"][3].trim()}` 
        ); 
 
        // Material property comments (must match the comment array contents) 
        finalOutput = finalOutput.replace( 
            /(\s{2}E: [\d.-]+)/, 
            `$1 ${YAML_COMMENTS.E.trim()}` 
        ); 
        finalOutput = finalOutput.replace( 
            /(\s{2}nu: [\d.-]+)/, 
            `$1 ${YAML_COMMENTS.nu.trim()}` 
        ); 
 
        // Optimization parameters (same line) 
        finalOutput = finalOutput.replace( 
            /(\s{2}min_density: [\d.-]+)/, 
            `$1 ${YAML_COMMENTS.min_density.trim()}` 
        ); 
        finalOutput = finalOutput.replace( 
            /(\s{2}max_density_initial_add: [\d.-]+)/, 
            `$1 ${YAML_COMMENTS.max_density_initial_add.trim()}` 
        ); 
        finalOutput = finalOutput.replace( 
            /(\s{2}density_clamp_max: [\d.-]+)/, 
            `$1 ${YAML_COMMENTS.density_clamp_max.trim()}` 
        ); 
 
        // Solver parameters (same line) 
        finalOutput = finalOutput.replace( 
            /(\s{2}solver_type: \w+)/, 
            `$1 ${YAML_COMMENTS.solver_type.trim()}` 
        ); 
        finalOutput = finalOutput.replace( 
            /(\s{2}tolerance: [\d.e-]+)/, 
            `$1 ${YAML_COMMENTS.tolerance.trim()}` 
        ); 
        finalOutput = finalOutput.replace( 
            /(\s{2}max_iterations: \d+)/, 
            `$1 ${YAML_COMMENTS.max_iterations.trim()}` 
        ); 
        finalOutput = finalOutput.replace( 
            /(\s{2}diagonal_shift_factor: [\d.e-]+)/, 
            `$1 ${YAML_COMMENTS.diagonal_shift_factor.trim()}` 
        ); 
        finalOutput = finalOutput.replace( 
            /(\s{2}gpu_method: \w+)/, 
            `$1 ${YAML_COMMENTS.gpu_method.trim()}` 
        ); 
        finalOutput = finalOutput.replace( 
            /(\s{2}krylov_solver: \w+)/, 
            `$1 ${YAML_COMMENTS.krylov_solver.trim()}` 
        ); 
         
        // Root scalar parameters (single line comments injected earlier, fixing up now) 
        finalOutput = finalOutput.replace( 
            /number_of_iterations: (\d+)\n# Number of optimization iterations/, 
            `# Number of optimization iterations. Set to 0 for a single FEM analysis run.\nnumber_of_iterations: $1` 
        ); 
        finalOutput = finalOutput.replace( 
            /l1_stress_allowable: ([\d.-]+)\n# Target maximum allowable L1 stress norm/, 
            `# Target maximum allowable L1 stress norm (constraint value).\nl1_stress_allowable: $1` 
        ); 
 
 
        return finalOutput.replace(/\n\s*\n\s*\n/g, '\n\n'); // Remove triple or more newlines 
    } 
 
    // [END] MODIFIED COMMENT INJECTION LOGIC 
 
    //--------------------------------------------------------------- 
    // Download configuration as YAML (UPDATED) 
    //--------------------------------------------------------------- 
    function downloadConfig() { 
        const updatedConfig = updateConfigFromScene();  
        if (!updatedConfig) { 
            alert("No configuration to download. Please load a model first."); 
            return; 
        } 
         
        // 1. Generate clean YAML string 
        // The 'sortKeys: false' prevents js-yaml from alphabetically sorting the keys, 
        // which is crucial for maintaining the order of the geometry shapes. 
        const cleanYamlString = jsyaml.dump(updatedConfig, { indent: 2, lineWidth: -1, sortKeys: false }); 
 
        // 2. Inject comments manually 
        const commentedYamlString = injectYamlComments(cleanYamlString, updatedConfig); 
 
        // 3. Save as .yaml file 
        const blob = new Blob([commentedYamlString], {type: "application/x-yaml"}); 
        saveAs(blob, "modified_fem_config.yaml"); 
    } 
     
    // Add event listeners (Unchanged) 
    downloadBtn.addEventListener("click", downloadConfig); 
    iterationsInput.addEventListener("change", updateConfigFromScene); 
    stressInput.addEventListener("change", updateConfigFromScene); 
    downloadBtn.disabled = true; 
 
    // File Input Logic (MODIFIED to remove JSON) 
    document.getElementById("fileInput").addEventListener("change", function(e) { 
        var file = e.target.files[0]; 
        if (!file) { 
            document.getElementById("instructions").textContent = "No file selected. Please choose a YAML file."; 
            return; 
        } 
 
        clearScene(); 
        document.getElementById("instructions").textContent = "Loading file..."; 
 
        var reader = new FileReader(); 
        reader.onload = function(ev) { 
            try { 
                var configText = ev.target.result; 
                var config; 
 
                if (file.name.toLowerCase().endsWith('.yaml') || file.name.toLowerCase().endsWith('.yml')) { 
                    config = jsyaml.load(configText); 
                } else { 
                    throw new Error("Unsupported file type. Please select .yaml or .yml."); 
                } 
 
                buildScene(config); 
                document.getElementById("instructions").innerHTML =  
                    "File loaded successfully. You can now drag objects and download the modified configuration.<hr style='margin: 5px 0; border: 0.5px solid #ccc;'>" + 
                    "**Usage:**<br>" + 
                    "1. Click on any blue or red shape to select it.<br>" + 
                    "2. Drag the colored gizmo arrows to **move** the object.<br>" + 
                    "3. Set iteration parameters above.<br>" + 
                    "4. Click the **Download** button to save your modified config as YAML."; 
            } catch(err) { 
                console.error("Parse error:", err); 
                alert("Error parsing config file: " + err.message); 
                document.getElementById("instructions").textContent = "Error loading file. Please try again."; 
            } 
        }; 
 
        reader.onerror = function(ev) { 
            console.error("File read error:", ev.target.error); 
            alert("Error reading file. Please try again."); 
            document.getElementById("instructions").textContent = "Error reading file. Please try again."; 
        }; 
 
        reader.readAsText(file); 
    }); 
 
    // Mesh Interaction Logic (Unchanged) 
    scene.onPointerDown = function(evt, pickResult) { 
        if (pickResult.hit && pickResult.pickedMesh) { 
            const mesh = pickResult.pickedMesh; 
            const configInfo = meshToConfigMap.get(mesh.name); 
             
            if (configInfo) { 
                gizmoManager.attachToMesh(mesh); 
                const { type, configKey } = configInfo; 
                const config = currentConfig.geometry[configKey];  
                 
                let infoText = `Selected: **${configKey}**\n`; 
                infoText += `Type: ${type}\n`; 
                infoText += `Action: ${config.action}\n`; 
                infoText += `Center (FEM): [${config.center.map(v => v.toFixed(2)).join(", ")}]\n`;  
                 
                if (type === "sphere") { 
                    infoText += `Diameter: ${config.diameter.toFixed(2)}\n`; 
                } else if (type === "box") { 
                    infoText += `Side: ${config.side.toFixed(2)}\n`; 
                } 
                 
                objectInfoDiv.textContent = infoText; 
            } else { 
                gizmoManager.attachToMesh(null); 
                objectInfoDiv.textContent = "No object selected"; 
            } 
        } else { 
            gizmoManager.attachToMesh(null); 
            objectInfoDiv.textContent = "No object selected"; 
        } 
    }; 
 
    gizmoManager.gizmos.positionGizmo.onDragEndObservable.add(() => { 
        updateConfigFromScene(); 
         
        if (gizmoManager.gizmos.positionGizmo.attachedMesh) { 
            const mesh = gizmoManager.gizmos.positionGizmo.attachedMesh; 
            const configInfo = meshToConfigMap.get(mesh.name); 
             
            if (configInfo) { 
                const { type, configKey } = configInfo; 
                const config = currentConfig.geometry[configKey];  
                 
                let infoText = `Selected: **${configKey}**\n`; 
                infoText += `Type: ${type}\n`; 
                infoText += `Action: ${config.action}\n`; 
                infoText += `Center (FEM): [${config.center.map(v => v.toFixed(2)).join(", ")}]\n`;  
                 
                if (type === "sphere") { 
                    infoText += `Diameter: ${config.diameter.toFixed(2)}\n`; 
                } else if (type === "box") { 
                    infoText += `Side: ${config.side.toFixed(2)}\n`; 
                } 
                 
                objectInfoDiv.textContent = infoText; 
            } 
        } 
    }); 
     
    // Initial setup 
    createCoordinateAxes(5); 
    gizmoManager.gizmos.positionGizmo.xGizmo.dragBehavior.useObjectOrientationForDragging = false; 
    gizmoManager.gizmos.positionGizmo.yGizmo.dragBehavior.useObjectOrientationForDragging = false; 
    gizmoManager.gizmos.positionGizmo.zGizmo.dragBehavior.useObjectOrientationForDragging = false; 
     
    document.getElementById("instructions").innerHTML =  
        "Please load an existing FEM config file (.yaml or .yml) to begin.<br>" + 
        "<hr style='margin: 5px 0; border: 0.5px solid #ccc;'>" + 
        "**Usage:**<br>" + 
        "1. Click on any blue or red shape to select it.<br>" + 
        "2. Drag the colored gizmo arrows to **move** the object.<br>" + 
        "3. Set iteration parameters above.<br>" + 
        "4. Click the **Download** button to save your modified config as YAML."; 
 
    // Render loop 
    engine.runRenderLoop(function() { 
        scene.render(); 
    }); 
     
    window.addEventListener("resize", function() { 
        engine.resize(); 
    }); 
 
</script> 
</body> 
</html> 
"// # FILE: .\SOLVER\CPUSolver.jl";
module CPUSolver

using LinearAlgebra, SparseArrays, Base.Threads, Printf
using ..Element

export MatrixFreeSystem, solve_system_cpu

struct MatrixFreeSystem{T}
    nodes::Matrix{T}
    elements::Matrix{Int}
    E::T
    nu::T
    bc_indicator::Matrix{T}
    free_dofs::Vector{Int}
    constrained_dofs::Vector{Int}
    density::Vector{T}
    min_stiffness_threshold::T 
    
    canonical_ke::Matrix{T}
end


"""
    MatrixFreeSystem(...)
"""
function MatrixFreeSystem(nodes::Matrix{T}, elements::Matrix{Int}, E::T, nu::T,
                          bc_indicator::Matrix{T}, density::Vector{T}=nothing,
                          min_stiffness_threshold::T=Float32(1.0e-3)) where T
                            
    nElem = size(elements, 1)
    if density === nothing; density = ones(T, nElem); end

    nNodes = size(nodes, 1)
    ndof   = nNodes * 3
    constrained = falses(ndof)
    @inbounds for i in 1:nNodes
        if bc_indicator[i,1]>0; constrained[3*(i-1)+1]=true; end
        if bc_indicator[i,2]>0; constrained[3*(i-1)+2]=true; end
        if bc_indicator[i,3]>0; constrained[3*(i-1)+3]=true; end
    end

    free_dofs        = findall(!, constrained)
    constrained_dofs = findall(x->x, constrained)

    
    
    n1, n2, n4, n5 = nodes[elements[1,1], :], nodes[elements[1,2], :], nodes[elements[1,4], :], nodes[elements[1,5], :]
    dx, dy, dz = norm(n2-n1), norm(n4-n1), norm(n5-n1)
    canonical_ke = Element.get_canonical_stiffness(dx, dy, dz, nu)

    return MatrixFreeSystem(nodes, elements, E, nu, bc_indicator,
                            free_dofs, constrained_dofs, density,
                            min_stiffness_threshold, canonical_ke) 
end

"""
    apply_stiffness(system, x)

Matrix-free multiplication K*x using canonical stiffness.
"""
function apply_stiffness(system::MatrixFreeSystem{T}, x::Vector{T}) where T
    nNodes = size(system.nodes, 1)
    ndof   = nNodes * 3
    nElem  = size(system.elements, 1)

    result = zeros(T, ndof)
    result_local = [zeros(T, ndof) for _ in 1:Threads.nthreads()]
    
    Ke_base = system.canonical_ke

    @threads for e in 1:nElem
        
        
        dens = system.density[e]
        if dens < system.min_stiffness_threshold
            continue
        end
        
        tid  = Threads.threadid()
        conn = view(system.elements, e, :)
        
        
        factor = system.E * dens

        
        u_elem = zeros(T, 24)
        for i in 1:8
            node_id = conn[i]
            base = 3*(node_id-1)
            u_elem[3*(i-1)+1] = x[base+1]
            u_elem[3*(i-1)+2] = x[base+2]
            u_elem[3*(i-1)+3] = x[base+3]
        end

        
        f_elem = (Ke_base * u_elem) .* factor

        
        for i in 1:8
            node_id = conn[i]
            base = 3*(node_id-1)
            result_local[tid][base+1] += f_elem[3*(i-1)+1]
            result_local[tid][base+2] += f_elem[3*(i-1)+2]
            result_local[tid][base+3] += f_elem[3*(i-1)+3]
        end
    end

    for r in result_local
        result .+= r
    end
    return result
end

function apply_system(system::MatrixFreeSystem{T}, x::Vector{T}) where T
    return apply_stiffness(system, x)
end

function apply_system_free_dofs(system::MatrixFreeSystem{T}, x_free::Vector{T}) where T
    nNodes = size(system.nodes, 1)
    ndof   = nNodes * 3
    x_full = zeros(T, ndof)
    x_full[system.free_dofs] = x_free
    result_full = apply_system(system, x_full)
    return result_full[system.free_dofs]
end


"""
    compute_diagonal_preconditioner(system)
"""
function compute_diagonal_preconditioner(system::MatrixFreeSystem{T}) where T
    nNodes = size(system.nodes, 1)
    ndof   = nNodes*3
    nElem  = size(system.elements, 1)
    
    diag_vec = zeros(T, ndof)
    diag_local = [zeros(T, ndof) for _ in 1:Threads.nthreads()]
    
    Ke_base = system.canonical_ke

    @threads for e in 1:nElem
        dens = system.density[e]
        if dens < system.min_stiffness_threshold
            continue
        end
        
        tid  = Threads.threadid()
        conn = view(system.elements, e, :)
        factor = system.E * dens

        for i in 1:8
            node_id = conn[i]
            base_dof = 3*(i-1)
            
            diag_val_x = Ke_base[base_dof+1, base_dof+1] * factor
            diag_val_y = Ke_base[base_dof+2, base_dof+2] * factor
            diag_val_z = Ke_base[base_dof+3, base_dof+3] * factor
            
            idx = 3*(node_id-1)
            diag_local[tid][idx+1] += diag_val_x
            diag_local[tid][idx+2] += diag_val_y
            diag_local[tid][idx+3] += diag_val_z
        end
    end

    for d in diag_local
        diag_vec .+= d
    end
    return diag_vec
end


function matrix_free_cg_solve(system::MatrixFreeSystem{T}, f::Vector{T};
                              max_iter=1000, tol=1e-6, use_precond=true,
                              shift_factor::T=Float32(1.0e-6)) where T  
    f_free = f[system.free_dofs]
    n_free = length(system.free_dofs)
    x_free = zeros(T, n_free)

    diag_full = compute_diagonal_preconditioner(system)
    diag_free = diag_full[system.free_dofs]

    shift = T(0.0)
    try
        max_diag = maximum(diag_free)
        shift = shift_factor * max_diag
        println("CPUSolver: Applying diagonal shift: $shift (Factor: $shift_factor)")
    catch e
        @warn "Could not calculate diagonal shift: $e"
    end
    
    r = copy(f_free)
    
    
    diag_free[diag_free .<= shift] .= shift
    
    z = use_precond ? r ./ diag_free : copy(r)
    p = copy(z)
    rz_old = dot(r, z)

    println("Starting matrix-free CG solve with $(n_free) unknowns...")
    total_time = 0.0
    
    norm_f = norm(f_free)
    if norm_f == 0
        return zeros(T, length(f))
    end

    for iter in 1:max_iter
        iter_start = time()
        
        Ap = apply_system_free_dofs(system, p) .+ (shift .* p)
        
        alpha = rz_old / dot(p, Ap)
        x_free .+= alpha .* p
        r .-= alpha .* Ap
        
        res_norm = norm(r) / norm_f
        total_time += (time() - iter_start)

        if res_norm < tol
            println("CG converged in $iter iterations, residual = $res_norm, total time = $total_time sec")
            break
        end

        diag_free[diag_free .<= shift] .= shift
        z = use_precond ? r ./ diag_free : copy(r)
        
        rz_new = dot(r, z)
        beta = rz_new / rz_old
        p .= z .+ beta .* p
        rz_old = rz_new
    end

    x_full = zeros(T, length(f))
    x_full[system.free_dofs] = x_free
    return x_full
end

function solve_system_cpu(nodes::Matrix{T}, elements::Matrix{Int}, E::T, nu::T,
                          bc_indicator::Matrix{T}, f::Vector{T};
                          max_iter=1000, tol=1e-6, use_precond=true,
                          density::Vector{T}=nothing,
                          shift_factor::T=Float32(1.0e-6),
                          min_stiffness_threshold::T=Float32(1.0e-3)) where T   
                            
    system = MatrixFreeSystem(nodes, elements, E, nu, bc_indicator, density, min_stiffness_threshold)
    
    solve_start = time()
    solution = matrix_free_cg_solve(system, f, max_iter=max_iter, tol=tol, 
                                    use_precond=use_precond, shift_factor=shift_factor)
    solve_end = time()
    @printf("Total solution time (matrix-free CPU): %.6f sec\n", solve_end - solve_start)
    return solution
end

end
"// # FILE: .\SOLVER\DirectSolver.jl";
module DirectSolver

using LinearAlgebra, SparseArrays, Base.Threads, Printf
using ..Element
using ..Boundary
using ..Mesh

export solve_system

"""
    assemble_global_stiffness_parallel_optimized(nodes, elements, E, nu, density, min_stiffness_threshold)

Pre-allocating assembler for CPU Direct solver.
"""
function assemble_global_stiffness_parallel_optimized(nodes::Matrix{Float32},
                                                      elements::Matrix{Int},
                                                      E::Float32,
                                                      nu::Float32,
                                                      density::Vector{Float32},
                                                      min_stiffness_threshold::Float32) 
                                                     
    nElem = size(elements, 1)
    ndof = size(nodes, 1) * 3

    
    active_indices = findall(d -> d >= min_stiffness_threshold, density)
    nActive = length(active_indices)
    
    if nActive == 0; error("No active elements."); end

    
    n1, n2, n4, n5 = nodes[elements[1,1], :], nodes[elements[1,2], :], nodes[elements[1,4], :], nodes[elements[1,5], :]
    dx, dy, dz = norm(n2-n1), norm(n4-n1), norm(n5-n1)
    Ke_base = Element.get_canonical_stiffness(dx, dy, dz, nu)

    
    entries_per_elem = 576
    total_entries = nActive * entries_per_elem
    I_vec = Vector{Int32}(undef, total_entries)
    J_vec = Vector{Int32}(undef, total_entries)
    V_vec = Vector{Float32}(undef, total_entries)

    
    Threads.@threads for t_idx in 1:length(active_indices)
        e = active_indices[t_idx]
        offset = (t_idx - 1) * entries_per_elem
        factor = E * density[e]
        conn = view(elements, e, :)
        
        cnt = 0
        @inbounds for i in 1:8
            row_idx = 3*(conn[i]-1)
            for r in 1:3
                g_row = row_idx + r
                for j in 1:8
                    col_idx = 3*(conn[j]-1)
                    for c in 1:3
                        g_col = col_idx + c
                        cnt += 1
                        
                        I_vec[offset+cnt] = Int32(g_row)
                        J_vec[offset+cnt] = Int32(g_col)
                        V_vec[offset+cnt] = Ke_base[3*(i-1)+r, 3*(j-1)+c] * factor
                    end
                end
            end
        end
    end

    K_global = sparse(I_vec, J_vec, V_vec, ndof, ndof)
    
    return (K_global + K_global') / 2.0f0
end

"""
    solve_system(...)
"""
function solve_system(nodes::Matrix{T}, elements::Matrix{Int}, E::T, nu::T,
                      bc_indicator::Matrix{T}, f::Vector{T};
                      density::Vector{T}=nothing,
                      shift_factor::T=Float32(1.0e-6),
                      min_stiffness_threshold::T=Float32(1.0e-3)) where T    
                        
    nElem = size(elements,1)
    if density === nothing
        density = ones(T, nElem)
    end

    nNodes = size(nodes, 1)
    ndof   = nNodes * 3

    constrained = falses(ndof)
    for i in 1:nNodes
        if bc_indicator[i,1]>0; constrained[3*(i-1)+1]=true; end
        if bc_indicator[i,2]>0; constrained[3*(i-1)+2]=true; end
        if bc_indicator[i,3]>0; constrained[3*(i-1)+3]=true; end
    end
    free_dofs = findall(!, constrained)

    
    K_global = assemble_global_stiffness_parallel_optimized(nodes, elements, E, nu, density, min_stiffness_threshold)

    K_reduced = K_global[free_dofs, free_dofs]
    F_reduced = f[free_dofs]

    try
        max_diag = maximum(abs.(diag(K_reduced)))
        shift = shift_factor * max_diag
        println("DirectSolver: Applying diagonal shift: $shift (Factor: $shift_factor)")
        K_reduced = K_reduced + shift * I
    catch e
        @warn "Could not apply diagonal shift: $e"
    end
    
    println("Solving linear system via LU factorization (CPU Direct).")
    U_reduced = K_reduced \ F_reduced

    U_full = zeros(T, ndof)
    U_full[free_dofs] = U_reduced

    return U_full
end

end
"// # FILE: .\SOLVER\GPUSolver.jl";
module GPUSolver

using LinearAlgebra, SparseArrays, Printf
using CUDA          
using CUDA.CUSPARSE     
using Krylov, LinearOperators  
using ..Element

export solve_system_gpu





function print_section_header(title::String)
    width = 80
    println("\n" * "="^width)
    padding = (width - length(title) - 2) ÷ 2
    println(" "^padding * title)
    println("="^width)
end

function print_subsection(title::String)
    println("\n" * "-"^80)
    println("  $title")
    println("-"^80)
end

function format_memory(bytes::Float64)
    if bytes >= 1024^3
        return @sprintf("%.2f GB", bytes / 1024^3)
    elseif bytes >= 1024^2
        return @sprintf("%.2f MB", bytes / 1024^2)
    else
        return @sprintf("%.2f KB", bytes / 1024)
    end
end

function get_free_dofs(bc_indicator::Matrix{T}) where T
    nNodes = size(bc_indicator, 1)
    ndof   = nNodes * 3
    constrained = falses(ndof)
    @inbounds for i in 1:nNodes
        if bc_indicator[i,1] > 0; constrained[3*(i-1)+1] = true; end
        if bc_indicator[i,2] > 0; constrained[3*(i-1)+2] = true; end
        if bc_indicator[i,3] > 0; constrained[3*(i-1)+3] = true; end
    end
    return findall(!, constrained)
end





function assemble_sparse_matrix_optimized(nodes::Matrix{T}, elements::Matrix{Int}, 
                                          E::T, nu::T, density::Vector{T}, 
                                          min_stiffness_threshold::T) where T
    
    print_section_header("GPU SOLVER - MATRIX ASSEMBLY")
    
    assembly_start = time()
    
    nElem = size(elements, 1)
    nNodes = size(nodes, 1)
    ndof = nNodes * 3

    
    active_indices = findall(d -> d >= min_stiffness_threshold, density)
    nActive = length(active_indices)
    
    if nActive == 0
        error("❌ No active elements found. Check density initialization or threshold.")
    end

    @printf("  Total elements:        %12d\n", nElem)
    @printf("  Active elements:       %12d (%.1f%%)\n", nActive, 100.0 * nActive / nElem)
    @printf("  Total DOFs:            %12d\n", ndof)
    @printf("  Density threshold:     %12.6f\n", min_stiffness_threshold)
    println()

    
    canonical_start = time()
    n1 = nodes[elements[1,1], :]
    n2 = nodes[elements[1,2], :] 
    n4 = nodes[elements[1,4], :] 
    n5 = nodes[elements[1,5], :] 
    
    dx = norm(n2 - n1)
    dy = norm(n4 - n1)
    dz = norm(n5 - n1)
    
    Ke_base = Element.get_canonical_stiffness(dx, dy, dz, nu)
    canonical_time = time() - canonical_start
    
    @printf("  Element size:          %.6f × %.6f × %.6f m\n", dx, dy, dz)
    @printf("  Canonical K computed:  %.3f ms\n", canonical_time * 1000)
    println()

    
    entries_per_elem = 576
    total_entries = nActive * entries_per_elem
    
    estimated_mem = total_entries * (4 + 4 + 4) / 1024^2  
    @printf("  Matrix entries:        %12d\n", total_entries)
    @printf("  Estimated memory:      %12.2f MB\n", estimated_mem)
    println()

    alloc_start = time()
    I_vec = Vector{Int32}(undef, total_entries)
    J_vec = Vector{Int32}(undef, total_entries)
    V_vec = Vector{T}(undef, total_entries)
    alloc_time = time() - alloc_start

    @printf("  Memory allocated:      %.3f ms\n", alloc_time * 1000)
    println("  Assembling element contributions (parallel)...")
    
    
    thread_assembly_start = time()
    
    Threads.@threads for t_idx in 1:length(active_indices)
        e = active_indices[t_idx]
        offset = (t_idx - 1) * entries_per_elem
        factor = E * density[e]
        conn = view(elements, e, :)
        
        cnt = 0
        @inbounds for i in 1:8
            row_node = conn[i]
            row_base_dof = 3 * (row_node - 1)
            
            for r_dof in 1:3
                global_row = row_base_dof + r_dof
                local_row = 3*(i-1) + r_dof
                
                for j in 1:8
                    col_node = conn[j]
                    col_base_dof = 3 * (col_node - 1)
                    
                    for c_dof in 1:3
                        global_col = col_base_dof + c_dof
                        local_col = 3*(j-1) + c_dof
                        
                        cnt += 1
                        idx = offset + cnt
                        
                        I_vec[idx] = Int32(global_row)
                        J_vec[idx] = Int32(global_col)
                        V_vec[idx] = Ke_base[local_row, local_col] * factor
                    end
                end
            end
        end
    end
    
    thread_assembly_time = time() - thread_assembly_start
    @printf("  Assembly completed:    %.3f s (%.1f elem/s)\n", 
            thread_assembly_time, nActive / thread_assembly_time)
    println()

    
    sparse_start = time()
    K_cpu = sparse(I_vec, J_vec, V_vec, ndof, ndof)
    sparse_time = time() - sparse_start
    
    @printf("  Sparse matrix built:   %.3f s\n", sparse_time)
    
    
    symmetrize_start = time()
    K_cpu = (K_cpu + K_cpu') / T(2.0)
    symmetrize_time = time() - symmetrize_start
    
    @printf("  Symmetrized:           %.3f s\n", symmetrize_time)
    
    
    nnz_K = nnz(K_cpu)
    sparsity = 100.0 * (1.0 - nnz_K / (ndof * ndof))
    @printf("  Non-zeros:             %12d\n", nnz_K)
    @printf("  Sparsity:              %12.2f%%\n", sparsity)
    println()
    
    diag_K = diag(K_cpu)
    
    total_assembly_time = time() - assembly_start
    @printf("  TOTAL ASSEMBLY TIME:   %.3f s\n", total_assembly_time)
    println("="^80)
    println()

    return K_cpu, diag_K
end





function gpu_sparse_cg_solve(nodes::Matrix{T}, elements::Matrix{Int}, E::T, nu::T,
                             bc_indicator::Matrix{T}, f::Vector{T},
                             density::Vector{T};
                             max_iter=1000, tol=1e-6,
                             shift_factor::T=Float32(1.0e-6),
                             min_stiffness_threshold::T=Float32(1.0e-3),
                             config::Dict=Dict()) where T
                             
    total_solve_start = time()
    
    CUDA.allowscalar(false)
    
    
    K_cpu, diag_K = assemble_sparse_matrix_optimized(nodes, elements, E, nu, density, min_stiffness_threshold)
    
    ndof = size(K_cpu, 1)
    free_dofs = get_free_dofs(bc_indicator)
    
    
    current_iter = get(config, "current_iteration", 0)
    if current_iter > 0
        print_section_header("GPU SOLVER - NATIVE CG (ITERATION $current_iter)")
    else
        print_section_header("GPU SOLVER - NATIVE CG")
    end
    
    @printf("  Free DOFs:             %12d / %d (%.1f%%)\n", 
            length(free_dofs), ndof, 100.0 * length(free_dofs) / ndof)
    println()
    
    
    reduction_start = time()
    K_free_cpu = K_cpu[free_dofs, free_dofs]
    f_free_cpu = f[free_dofs]
    reduction_time = time() - reduction_start
    
    @printf("  System reduction:      %.3f s\n", reduction_time)
    
    
    try
        max_diag = maximum(abs.(diag(K_free_cpu)))
        min_diag = minimum(abs.(diag(K_free_cpu)))
        cond_estimate = max_diag / max(min_diag, 1e-12)
        
        shift = shift_factor * max_diag
        @printf("  Max diagonal:          %.6e\n", max_diag)
        @printf("  Min diagonal:          %.6e\n", min_diag)
        @printf("  Condition estimate:    %.6e\n", cond_estimate)
        @printf("  Diagonal shift:        %.6e (factor: %.1e)\n", shift, shift_factor)
        
        K_free_cpu = K_free_cpu + shift * I
    catch e
        @warn "Could not apply diagonal shift: $e"
    end
    println()

    
    gpu_transfer_start = time()
    A_gpu = CUDA.CUSPARSE.CuSparseMatrixCSR(K_free_cpu)
    b_gpu = CuVector(f_free_cpu)
    x_gpu = CUDA.zeros(T, length(f_free_cpu))
    gpu_transfer_time = time() - gpu_transfer_start

    @printf("  GPU transfer:          %.3f s\n", gpu_transfer_time)
    
    
    norm_b = norm(b_gpu)
    @printf("  Force norm:            %.6e\n", norm_b)
    
    if norm_b == 0
        println("\n⚠️  Zero force vector. Solution is zero.")
        println("="^80)
        x_full = zeros(T, ndof)
        return x_full
    end
    println()

    
    println("  Starting CG iterations (printing every 1000 iterations)...")
    println("  " * "-"^66)
    @printf("  %8s %16s %16s %12s\n", "Iter", "Residual", "Rel. Residual", "Time (s)")
    println("  " * "-"^66)
    
    
    r_gpu = CUDA.zeros(T, length(b_gpu))
    p_gpu = CUDA.zeros(T, length(b_gpu))
    Ap_gpu = CUDA.zeros(T, length(b_gpu))
    
    
    CUDA.CUSPARSE.mv!('N', T(1.0), A_gpu, x_gpu, T(0.0), r_gpu, 'O')  # r = A*x
    r_gpu .= b_gpu .- r_gpu  
    
    
    p_gpu .= r_gpu
    
    rsold_gpu = dot(r_gpu, r_gpu)
    
    cg_start = time()
    converged = false
    final_iter = 0
    
    
    print_interval = 1000

    for iter in 1:max_iter
        
        CUDA.CUSPARSE.mv!('N', T(1.0), A_gpu, p_gpu, T(0.0), Ap_gpu, 'O')
        
        denom = dot(p_gpu, Ap_gpu)
        
        if abs(denom) < 1e-20
            @warn "  CG breakdown: denominator too small at iteration $iter"
            break
        end

        alpha = rsold_gpu / denom
        
        
        CUDA.CUBLAS.axpy!(length(x_gpu), alpha, p_gpu, 1, x_gpu, 1)
        
        
        CUDA.CUBLAS.axpy!(length(r_gpu), -alpha, Ap_gpu, 1, r_gpu, 1)
        
        rsnew_gpu = dot(r_gpu, r_gpu)
        residual_norm = sqrt(rsnew_gpu) / norm_b
        
        
        should_print = (iter == 1) || (iter % print_interval == 0) || (residual_norm < tol)
        
        if should_print
            elapsed = time() - cg_start
            @printf("  %8d %16.8e %16.8e %12.3f\n", iter, sqrt(rsnew_gpu), residual_norm, elapsed)
        end
        
        
        if residual_norm < tol
            converged = true
            final_iter = iter
            # Print final iteration if it wasn't already printed
            if !should_print
                elapsed = time() - cg_start
                @printf("  %8d %16.8e %16.8e %12.3f\n", iter, sqrt(rsnew_gpu), residual_norm, elapsed)
            end
            break
        end
        
        
        beta = rsnew_gpu / rsold_gpu
        CUDA.CUBLAS.scal!(length(p_gpu), beta, p_gpu, 1)  
        CUDA.CUBLAS.axpy!(length(p_gpu), T(1.0), r_gpu, 1, p_gpu, 1)  
        
        rsold_gpu = rsnew_gpu
        final_iter = iter
    end
    
    cg_time = time() - cg_start
    println("  " * "-"^66)
    println()
    
    
    if converged
        @printf("  ✓ CONVERGED in %d iterations\n", final_iter)
    else
        @printf("  ⚠️  DID NOT CONVERGE (max iterations reached)\n")
    end
    @printf("  CG solve time:         %.3f s\n", cg_time)
    @printf("  Avg time/iteration:    %.3f ms\n", 1000.0 * cg_time / final_iter)
    println()

    
    transfer_back_start = time()
    x_free = Array(x_gpu)
    transfer_back_time = time() - transfer_back_start
    
    @printf("  GPU → CPU transfer:    %.3f ms\n", transfer_back_time * 1000)
    
    
    x_full = zeros(T, ndof)
    x_full[free_dofs] = x_free
    
    total_solve_time = time() - total_solve_start
    
    println()
    @printf("  TOTAL SOLVE TIME:      %.3f s\n", total_solve_time)
    println("="^80)
    println()
    
    return x_full
end





function gpu_krylov_solve(nodes::Matrix{T}, elements::Matrix{Int}, E::T, nu::T,
                          bc_indicator::Matrix{T}, f::Vector{T},
                          density::Vector{T};
                          solver=:cg, max_iter=1000, tol=1e-6, use_precond=true,
                          shift_factor::T=Float32(1.0e-6),
                          min_stiffness_threshold::T=Float32(1.0e-3),
                          config::Dict=Dict()) where T
                            
    total_solve_start = time()
    
    CUDA.allowscalar(false)

    
    K_cpu, diag_K = assemble_sparse_matrix_optimized(nodes, elements, E, nu, density, min_stiffness_threshold)
    
    ndof = size(K_cpu, 1)
    free_dofs = get_free_dofs(bc_indicator)
    
    
    current_iter = get(config, "current_iteration", 0)
    if current_iter > 0
        print_section_header("GPU SOLVER - KRYLOV.$solver (ITERATION $current_iter)")
    else
        print_section_header("GPU SOLVER - KRYLOV.$solver")
    end
    
    @printf("  Free DOFs:             %12d / %d (%.1f%%)\n", 
            length(free_dofs), ndof, 100.0 * length(free_dofs) / ndof)
    @printf("  Preconditioner:        %12s\n", use_precond ? "Jacobi" : "None")
    println()
    
    
    reduction_start = time()
    K_free_cpu = K_cpu[free_dofs, free_dofs]
    f_free_cpu = f[free_dofs]
    diag_free_cpu = diag_K[free_dofs]
    reduction_time = time() - reduction_start
    
    @printf("  System reduction:      %.3f s\n", reduction_time)
    
    
    try
        max_diag = maximum(abs.(diag(K_free_cpu)))
        min_diag = minimum(abs.(diag(K_free_cpu)))
        cond_estimate = max_diag / max(min_diag, 1e-12)
        
        shift = shift_factor * max_diag
        @printf("  Max diagonal:          %.6e\n", max_diag)
        @printf("  Min diagonal:          %.6e\n", min_diag)
        @printf("  Condition estimate:    %.6e\n", cond_estimate)
        @printf("  Diagonal shift:        %.6e (factor: %.1e)\n", shift, shift_factor)
        
        K_free_cpu = K_free_cpu + shift * I
        diag_free_cpu .+= shift
    catch e
        @warn "Could not apply diagonal shift: $e"
    end
    println()

    
    gpu_transfer_start = time()
    A_gpu = CUDA.CUSPARSE.CuSparseMatrixCSR(K_free_cpu)
    b_gpu = CuVector(f_free_cpu)
    gpu_transfer_time = time() - gpu_transfer_start

    @printf("  GPU transfer:          %.3f s\n", gpu_transfer_time)
    
    
    norm_b = norm(b_gpu)
    @printf("  Force norm:            %.6e\n", norm_b)
    
    if norm_b == 0
        println("\n⚠️  Zero force vector. Solution is zero.")
        println("="^80)
        x_full = zeros(T, ndof)
        return x_full
    end
    println()
    
    
    opM = nothing
    if use_precond
        precond_start = time()
        
        
        replace!(x -> x < 1e-12 ? T(1.0) : x, diag_free_cpu)
        d_gpu = CuVector(diag_free_cpu)
        
        function ldiv_jacobi!(y, x, d_gpu)
            y .= x ./ d_gpu
            return y
        end
        
        symmetric = true
        hermitian = true
        n = length(b_gpu)
        
        opM = LinearOperator(T, n, n, symmetric, hermitian, 
                             (y, x) -> ldiv_jacobi!(y, x, d_gpu))
        
        precond_time = time() - precond_start
        @printf("  Preconditioner setup:  %.3f ms\n", precond_time * 1000)
        println()
    end

    
    
    println("  Starting Krylov.$solver iterations...")
    println("  (Progress updates every 1000 iterations will appear below)")
    println()
    
    solve_start = time()
    iteration_count = Ref(0)
    last_print = Ref(0)
    print_interval = 1000
    
    # Create simple progress tracking that works with Krylov's internal iteration counter
    # We'll monitor the stats object after solve completes
    
    
    x_gpu, stats = if opM !== nothing
        if solver == :cg
            cg(A_gpu, b_gpu, M=opM, itmax=max_iter, rtol=tol, verbose=0, history=true)
        elseif solver == :minres
            minres(A_gpu, b_gpu, M=opM, itmax=max_iter, rtol=tol, verbose=0, history=true)
        elseif solver == :bicgstab
            bicgstab(A_gpu, b_gpu, M=opM, itmax=max_iter, rtol=tol, verbose=0, history=true)
        else
            error("Unknown Krylov solver: $solver")
        end
    else
        if solver == :cg
            cg(A_gpu, b_gpu, itmax=max_iter, rtol=tol, verbose=0, history=true)
        elseif solver == :minres
            minres(A_gpu, b_gpu, itmax=max_iter, rtol=tol, verbose=0, history=true)
        elseif solver == :bicgstab
            bicgstab(A_gpu, b_gpu, itmax=max_iter, rtol=tol, verbose=0, history=true)
        else
            error("Unknown Krylov solver: $solver")
        end
    end
    
    solve_time = time() - solve_start
    
    
    println()
    
    
    residuals = nothing
    if hasproperty(stats, :residuals) && !isnothing(stats.residuals) && length(stats.residuals) > 0
        residuals = stats.residuals
        println("  (Using stats.residuals)")
    elseif hasproperty(stats, :Residuals) && !isnothing(stats.Residuals) && length(stats.Residuals) > 0
        residuals = stats.Residuals
        println("  (Using stats.Residuals)")
    elseif hasproperty(stats, :rNorms) && !isnothing(stats.rNorms) && length(stats.rNorms) > 0
        residuals = stats.rNorms
        println("  (Using stats.rNorms)")
    else
        
        println("  Available stats fields: ", fieldnames(typeof(stats)))
    end
    
    if residuals !== nothing && length(residuals) > 0
        println("  " * "-"^66)
        @printf("  %8s %16s %16s %12s\n", "Iter", "Residual", "Rel. Residual", "Time (s)")
        println("  " * "-"^66)
        
        
        @printf("  %8d %16.8e %16.8e %12.3f\n", 
                1, residuals[1], residuals[1]/norm_b, 0.0)
        
        
        for i in 1000:1000:length(residuals)
            elapsed_est = solve_time * (i / length(residuals))
            @printf("  %8d %16.8e %16.8e %12.3f\n", 
                    i, residuals[i], residuals[i]/norm_b, elapsed_est)
        end
        
        
        niter_final = length(residuals)
        
        
        if niter_final % 1000 != 0
            @printf("  %8d %16.8e %16.8e %12.3f\n", 
                    niter_final, residuals[end], residuals[end]/norm_b, solve_time)
        end
        println("  " * "-"^66)
    else
        @warn "Residual history not available - enable with history=true"
    end
    
    println()
    
    
    if stats.solved
        @printf("  ✓ CONVERGED\n")
    else
        @printf("  ⚠️  DID NOT CONVERGE\n")
    end
    
    
    niter = if hasproperty(stats, :niter)
        stats.niter
    elseif residuals !== nothing
        length(residuals)
    else
        0
    end
    
    @printf("  Iterations:            %12d / %d\n", niter, max_iter)
    
    if residuals !== nothing && length(residuals) > 0
        @printf("  Initial residual:      %.6e\n", residuals[1])
        @printf("  Final residual:        %.6e\n", residuals[end])
        @printf("  Relative residual:     %.6e\n", residuals[end] / norm_b)
    end
    
    @printf("  Solve time:            %.3f s\n", solve_time)
    if niter > 0
        @printf("  Avg time/iteration:    %.3f ms\n", 1000.0 * solve_time / niter)
    end
    println()

    
    transfer_back_start = time()
    x_free = Array(x_gpu)
    transfer_back_time = time() - transfer_back_start
    
    @printf("  GPU → CPU transfer:    %.3f ms\n", transfer_back_time * 1000)
    
    
    x_full = zeros(T, ndof)
    x_full[free_dofs] = x_free
    
    total_solve_time = time() - total_solve_start
    
    println()
    @printf("  TOTAL SOLVE TIME:      %.3f s\n", total_solve_time)
    println("="^80)
    println()

    return x_full
end





function solve_system_gpu(nodes::Matrix{T}, elements::Matrix{Int}, E::T, nu::T,
                          bc_indicator::Matrix{T}, f::Vector{T},
                          density::Vector{T};
                          max_iter=1000, tol=1e-6, 
                          method=:native, solver=:cg, use_precond=true,
                          shift_factor::T=Float32(1.0e-6),
                          min_stiffness_threshold::T=Float32(1.0e-3),
                          config::Dict=Dict()) where T
                            
    @assert density !== nothing "You must provide a density array for GPU solver."
    
    if !CUDA.functional()
        error("CUDA is not functional on this system.")
    end
    
    println("\n")
    println("╔" * "═"^68 * "╗")
    println("║" * " "^20 * "GPU FEM SOLVER INITIATED" * " "^24 * "║")
    println("╚" * "═"^68 * "╝")
    println()
    
    
    gpu_info_start = time()
    free_mem, total_mem = CUDA.available_memory(), CUDA.total_memory()
    @printf("  GPU Device:            %s\n", CUDA.name(CUDA.device()))
    @printf("  Available memory:      %.2f GB / %.2f GB\n", 
            free_mem / 1024^3, total_mem / 1024^3)
    @printf("  Method:                %s\n", method == :native ? "Native CG" : "Krylov.$solver")
    @printf("  Tolerance:             %.2e\n", tol)
    @printf("  Max iterations:        %d\n", max_iter)
    println()
    
    overall_start = time()
    
    solution = if method == :native
        gpu_sparse_cg_solve(nodes, elements, E, nu, bc_indicator, f, density,
                           max_iter=max_iter, tol=tol, shift_factor=shift_factor,
                           min_stiffness_threshold=min_stiffness_threshold,
                           config=config)
    elseif method == :krylov
        gpu_krylov_solve(nodes, elements, E, nu, bc_indicator, f, density,
                        solver=solver, max_iter=max_iter, tol=tol, 
                        use_precond=use_precond, shift_factor=shift_factor,
                        min_stiffness_threshold=min_stiffness_threshold,
                        config=config)
    else
        error("Unknown method: $method. Use :native or :krylov.")
    end
    
    overall_time = time() - overall_start
    
    println("╔" * "═"^68 * "╗")
    println("║" * " "^20 * "GPU SOLVER COMPLETED" * " "^28 * "║")
    println("╠" * "═"^68 * "╣")
    @printf("║  Total time: %48.3f s  ║\n", overall_time)
    println("╚" * "═"^68 * "╝")
    println()
    
    return solution
end

end
"// # FILE: .\SOLVER\IterativeSolver.jl";
module IterativeSolver 
 
using LinearAlgebra, Printf 
using ..CPUSolver  # Use parent module's CPUSolver 
using ..GPUSolver  # Use parent module's GPUSolver 
 
export solve_system_iterative 
 
""" 
    solve_system_iterative(nodes, elements, E, nu, bc_indicator, f; 
                           solver_type=:matrix_free, max_iter=1000, tol=1e-6, 
                           use_precond=true, density=nothing, 
                           gpu_method=:native, krylov_solver=:cg, shift_factor=1e-6, 
                           min_stiffness_threshold=1e-3) 
 
High-level interface that dispatches between different solver types. 
""" 
function solve_system_iterative(nodes::Matrix{T}, elements::Matrix{Int}, E::T, nu::T, 
                                 bc_indicator::Matrix{T}, f::Vector{T}; 
                                 solver_type=:matrix_free, max_iter=1000, tol=1e-6, 
                                 use_precond=true, density::Vector{T}=nothing, 
                                 gpu_method=:native, krylov_solver=:cg, 
                                 shift_factor::T=Float32(1.0e-6), 
                                  
                                 min_stiffness_threshold::T=Float32(1.0e-3)) where T   
                                  
 
    if solver_type == :matrix_free 
        return CPUSolver.solve_system_cpu( 
            nodes, elements, E, nu, bc_indicator, f; 
            max_iter=max_iter, tol=tol, use_precond=use_precond,  
            density=density, shift_factor=shift_factor, 
             
            min_stiffness_threshold=min_stiffness_threshold  
             
        ) 
    elseif solver_type == :gpu 
        if density === nothing 
            error("You must provide a density array for GPU solver.") 
        end 
        return GPUSolver.solve_system_gpu( 
            nodes, elements, E, nu, bc_indicator, f, density; 
            max_iter=max_iter, tol=tol,  
            method=gpu_method, solver=krylov_solver, use_precond=use_precond, 
            shift_factor=shift_factor, 
             
            min_stiffness_threshold=min_stiffness_threshold 
             
        ) 
    else 
        error("Unknown solver type: $solver_type. Use :matrix_free or :gpu.") 
    end 
end 
 
end 
"// # FILE: .\SOLVER\solver.jl";
module Solver 
 
using CUDA 
using ..Helpers  
using ..DirectSolver: solve_system as solve_system_direct 
using ..IterativeSolver: solve_system_iterative 
 
 
export solve_system 
 
""" 
    choose_solver(nNodes, nElem, config) 
 
Determine the appropriate solver type based on config, problem size and available hardware. 
""" 
function choose_solver(nNodes, nElem, config) 
    solver_params = config["solver_parameters"] 
    configured_type = Symbol(lowercase(get(solver_params, "solver_type", "direct"))) 
 
    if configured_type == :direct 
        if nElem > 100_000 
            @warn "Direct solver requested for large mesh ($(nElem) elements). Switching to Matrix-Free iterative." 
            return :matrix_free 
        end 
        return :direct 
    elseif configured_type == :gpu 
        if CUDA.functional() && Helpers.has_enough_gpu_memory(nNodes, nElem) 
            println("GPU is available with sufficient memory. Using GPU solver.") 
            return :gpu 
        else 
            if CUDA.functional() 
                println("GPU is available but insufficient memory; falling back to CPU solver.") 
            else 
                println("No GPU available; falling back to CPU solver.") 
            end 
            return :matrix_free 
        end 
    elseif configured_type == :matrix_free 
        return :matrix_free 
    else 
        @warn "Unknown solver_type: $(configured_type). Defaulting to matrix_free." 
        return :matrix_free 
    end 
end 
 
""" 
    solve_system(...) 
 
Single entry point for all linear solvers. 
Dispatches to the correct solver based on problem size and density. 
""" 
function solve_system(nodes::Matrix{Float32}, 
                      elements::Matrix{Int}, 
                      E::Float32, 
                      nu::Float32, 
                      bc_indicator::Matrix{Float32}, 
                      F::Vector{Float32}; 
                      density::Vector{Float32}=nothing, 
                      config::Dict, 
                       
                      min_stiffness_threshold::Float32=Float32(1.0e-3)) 
                       
     
    nNodes = size(nodes, 1) 
    nElem = size(elements, 1) 
     
    solver_params = config["solver_parameters"] 
     
    solver_type = choose_solver(nNodes, nElem, config) 
     
     
    tol = Float32(get(solver_params, "tolerance", 1.0e-6)) 
    max_iter = Int(get(solver_params, "max_iterations", 1000)) 
    shift_factor = Float32(get(solver_params, "diagonal_shift_factor", 1.0e-6)) 
     
     
    use_precond = true 
    if solver_type == :gpu 
         
         
         
         
        # @warn "GPU solver forced to use UNPRECONDITIONED mode to bypass CUSPARSE IC(0) console dump/failure." 
    end 
     
 
 
    println("Dispatching to solver: :$(solver_type) with TOL=$(tol), MAX_ITER=$(max_iter)") 
 
    U_full = if solver_type == :direct 
        solve_system_direct(nodes, elements, E, nu, bc_indicator, F; 
                            density=density, 
                            shift_factor=shift_factor, 
                             
                            min_stiffness_threshold=min_stiffness_threshold) 
                             
    elseif solver_type == :gpu 
        gpu_method = Symbol(lowercase(get(solver_params, "gpu_method", "krylov"))) 
        krylov_solver = Symbol(lowercase(get(solver_params, "krylov_solver", "cg"))) 
 
        solve_system_iterative(nodes, elements, E, nu, bc_indicator, F; 
                             solver_type=:gpu, max_iter=max_iter, tol=tol, 
                             density=density, 
                             use_precond=use_precond,  
                             gpu_method=gpu_method, krylov_solver=krylov_solver, 
                             shift_factor=shift_factor, 
                              
                             min_stiffness_threshold=min_stiffness_threshold) 
                              
    else  
         
        solve_system_iterative(nodes, elements, E, nu, bc_indicator, F; 
                             solver_type=:matrix_free, max_iter=max_iter, tol=tol, 
                             use_precond=true, 
                             density=density, 
                             shift_factor=shift_factor, 
                              
                             min_stiffness_threshold=min_stiffness_threshold) 
                              
    end 
 
    return U_full 
end 
 
end 
 
 
